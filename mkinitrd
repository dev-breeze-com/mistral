#!/bin/bash
#
# Copyright 2017  Tsert.Inc, All Rights Reserved
# Copyright 2017  Pierre Innocent, All Rights Reserved
# Copyright 2004  Slackware Linux, Inc., Concord, CA, USA
# Copyright 2004  Patrick J. Volkerding, Concord, CA, USA
# Copyright 2007, 2008, 2009, 2010, 2011  Patrick J. Volkerding, Sebeka, MN, USA
# All rights reserved.
#
# Redistribution and use of this script, with or without modification, is
# permitted provided that the following conditions are met:
#
# 1. Redistributions of this script must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
#  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR IMPLIED
#  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
#  EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
#  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
#  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
#  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
#  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
#  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# Modified by Robby Workman <rworkman@slackware.com> 26 November 2007
#   to add support for mkinitrd.conf - No additional license terms added
# Modified by Alan Hicks <alan@slackware.com> 27 November 2007 to enable
#   passing arguments to kernel modules - No additional license terms added
#   volkerdi - feel free to remove these :)
# Modified by Eric Hameleers <alien@slackware.com> 3 April 2008
#   to add support custom keymaps - No additional license terms added
# Modified by Patrick Volkerding <volkerdi@slackware.com> 17 Dec 2008
#   Added support to bail out if kernel modules are requested for a kernel
#   version that is not installed (thanks to Eric Hameleers), be more
#   verbose about showing modules added to the initrd (thanks to
#   Ellington Santos), and if "mount" returns /dev/root as the root device,
#   use readlink to resolve the device pointed to by the /dev/root
#   symlink, changed modprobe to use --ignore-install to avoid catching
#   custom "install" lines and causing /sbin/modprobe to be copied to the
#   initrd (thanks to Ken Milmore).
#   Of course, license terms remain unchanged.
# Modified by Eric Hameleers <alien@slackware.com> 3 March 2010
#   Add lukskey option (-K). Automatically add kernel modules listed in
#   load-kernel-modules if that file is executable.
#   Yada yada yada.
# Modified by Patrick Volkerding <volkerdi@slackware.com> 21 August 2012
#   Add Btrfs multi-device filesystem support option (-b).
#
# Changelog
# 17-May-2019 <dev@breezeos.com>
#  * Modified it to fit an OpenRC installation with Breeze::OS encryption setup.
#
# 17-May-2019 <dev@breezeos.com>
#  * Removed compatibility to a Slackware mkinitrd installation.
#
# 17-Feb-2017 <dev@breezeos.com>
#  * Changed the '-C' option to fit Breeze::OS encryption setup.
#
#############################################################################

PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/libexec"
export PATH

MKINITRD_VERSION="0.9.0"
MKINITRD_NAME="BreezeOS Initrd"

BIN_ZIP=$(which gzip)
BIN_RSYNC=$(which rsync)
BIN_BLKID=$(which blkid)
BIN_LSBLK=$(which lsblk)
BIN_CRYPT=$(which cryptsetup)

# Don't include these things from /lib/udev/ in the initrd image
LIBUDEV_BLACKLIST="\
  ipod-set-info \
  check-mtp-device \
  check-ptp-camera \
  udev-configure-printer"

print_usage() {
  cat << EOF
Usage: mistral [OPTION]

mistral creates an initial ramdisk (actually an initramfs cpio+gzip
archive) used to load kernel modules that are needed to mount the
root filesystem, or other modules that might be needed before the
root filesystem is available.  Other binaries may be added to the
initrd, and the script is easy to modify.

  -h      Display help message
  -v      Display version information
  -c      Clear the existing initrd tree first
  -y      Assume yes on all questions

  -k      Kernel version to use
  -L      Add support for LVM partitions
  -R      Add support for RAID partitions
  -C      Add support for LUKS partitions
  -E      Add support for EFI partitions
  -m      Add the files in /etc/modprobe.d/ and /lib/modprobe.d/ to the initrd
  -U      Include udev in the initrd

  -f      Filesystem to use for root partition (must be used with -r)
  -r      Root partition device (must be used with -f)
  -o      Output image (default /boot/initramfs-breezeos-<kver>-<arch>.img)

  -l      Custom keymap to load. Like, 'nl' or 'de-latin1-nodeadkeys'
  -H      Device to resume from hibernation. Needs to be the name of
          the swap partition holding the hibernation image.
  -F      A space delimited list of filesystems to add to the initrd.
  -M      A space delimited list of kernel modules to load.
          Additional options may be added to use when loading the
          kernel modules (but in this case the entire list must be
          wrapped with double quotes).  Any dependencies of requested
          modules will also be added to the initrd.
  -s      Initrd source tree (default /var/cache/mistral/initrd-tree/)
  -D      A space delimited pair of luks encrypted block devices and
          luks names to be unlocked by the initrd using cryptsetup. All
		  devices that must be unlocked in order to access the root
		  filesystem must be specified. Can be specified more than once.
		  Use with '-r' parameter.
  -K      Use a USB key (fat-formatted) to unlock the root LUKS volume
          The parameter value is filename of a keyfile, as well as the label
          (or uuid) of the partition this file is on.  This way, you can unlock
          your computer automatically if you have a USB stick with your LUKS
          key inserted at boot. A passphrase will still be asked if the LUKS
          key can not be found.
          For example, if your USB thumb drive has a FAT partition with label
          "BRZCRYPTO" and the actual keyfile is called "/keys/breezeos.luks",
          then you need to pass: -K LABEL=BRZCRYPTO:/keys/breezeos.luks
  -b      Add /sbin/btrfs to enable scanning for a root filesystem that is
          part of a Btrfs multi-device filesystem.
  -P      Specify an initrd prefix, e.g. breezeos.
  -S      Add support for boot splash, .i.e fbsplash or plymouth
  -T      Specify boot splash theme, .e.g. breezeos, or breezeos:1280x1024
  -Z      Specify compression command, i.e. gzip or xz
  -N      Specify the initrd name, 'BreezeOS Initrd'.
  -V      Specify a directory for the overlay file tree

A simple example:  Build an initrd for a reiserfs root partition:

  mistral -c -F reiserfs

Another example:  Build an initrd image using Linux 2.6.35.4-smp kernel
modules for a system with an ext4 root partition on /dev/sdb3:

  mistral -c -k 2.6.35.4-smp -M 'mbcache jbd' -F ext4 -f ext4 -r /dev/sdb3

Note that if you are already logged in with /dev/sdb3 as your /
partition, and it is running ext4, this command works just the same:

  mistral -c -F ext4

EOF
}

crunch() {
  local answer=""
  read answer
  echo "$answer"
  return 0
}

prompt_yesno() {

  local answer="no"

  if [ "$ASSUME_YES" = "yes" ]; then
	answer="yes"
  else
	echo -n "[1;33m${1}, proceed (n/y) ? [0m"
	read answer
  fi

  if [ "$answer" = "y" -o "$answer" = "yes" -o "$answer" = "Y" ]; then
  	return 0
  fi

  return 1
}

copy_block_devices() {

  local devices=$(cat /proc/partitions)

  for device in $devices ; do
    if [ ! -r $RD_LAYOUT/dev/$device ]; then
      if [ -b /dev/$device ]; then
        if [ -L /dev/$device ]; then
          cp -a --parents $(readlink -e /dev/$device) $RD_LAYOUT/
        fi
        cp -a --parents /dev/$device $RD_LAYOUT/
      fi
    fi
  done

  return 0
}

clear_source_tree() {

  local answer="no"

  if [ -d "$RD_LAYOUT" ]; then
    if prompt_yesno "About to delete $RD_LAYOUT" ; then
		  rm -rf $RD_LAYOUT
    fi
  fi

  return 0
}

create_source_tree() {

  mkdir -p $RD_LAYOUT || exit 1
	mkdir -p $RD_LAYOUT/usr/lib || exit 1
  mkdir -p $RD_LAYOUT/etc/rd.conf || exit 1

  # Make sure a kernel module directory exists:
  mkdir -p $RD_LAYOUT/lib/modules/${RD_KVER} || exit 1

  # Add the initrd-tree skeleton:
  (
 	 cd $RD_LAYOUT
	 tar -xf /usr/share/mistral/initrd-tree.tar.gz
  )

  # Make sure we have any needed block devices
  copy_block_devices

  if [ -d /lib32 -a -h /lib ]; then
		if [ -d $RD_LAYOUT/lib -a ! -e $RD_LAYOUT/lib64 ]; then
			mv $RD_LAYOUT/lib $RD_LAYOUT/lib64
		fi

  	( cd $RD_LAYOUT ; ln -s lib64 lib )
  fi

  if [ -d /usr/lib32 -a -h /usr/lib ]; then
		if [ -d $RD_LAYOUT/usr/lib -a ! -e $RD_LAYOUT/usr/lib64 ]; then
  		mv $RD_LAYOUT/usr/lib $RD_LAYOUT/usr/lib64
		fi

  	( cd $RD_LAYOUT ; ln -s usr/lib64 usr/lib )
  fi

  return 0
}

build_busybox() {

  mkdir -p $RD_BUSYBOX || exit 1
	
  # Build the initrd-tree busybox:
  (
		cd $RD_BUSYBOX

		tar -xf /usr/share/mistral/busybox-1.31.0.tar.xz
		make menuconfig && make

		if [ $? = 0 ]; then
			cp busybox $RD_LAYOUT/bin/
		else
			echo "[1;31mError: failed to build packaged busybox[0m"
		fi
  )

  return 0
}

build_initrd_image() {

  # Make sure we have any needed block devices
  copy_block_devices

  if [ "$RD_OUTPUT" = "$(basename $RD_OUTPUT)" ]; then
		RD_OUTPUT=/boot/$RD_OUTPUT
  fi

  mkdir -p $(dirname $RD_OUTPUT) || exit 1

  if [ -e "$RD_OUTPUT" ]; then
    echo "[1;36mSaving previous ramdisk $RD_OUTPUT [0m"
		mv -f $RD_OUTPUT ${RD_OUTPUT}.old
  fi

  # Wrap the initrd as an initramfs image and move it into place:
  (
    cd $RD_LAYOUT
    find . | cpio -o -H newc | $BIN_ZIP -9c > $RD_OUTPUT
  )

  RD_CMDLINE="$RD_CMDLINE ro quiet vga=792 net.ifnames=0 console=tty1 consoleblank=0"

  echo "[1;32mCreated ramdisk $RD_OUTPUT -- done[0m"
  echo "[1;33mBoot cmdline is:[0m"
  echo "    [1;36m$RD_CMDLINE[0m"
  echo "Be sure to update your boot loader !"
  return 0
}

unify_libs() {
  awk '/=. \// { print $3 }' | sort -u
  return 0
}

copy_overlay() {

  echo "[1;36mCopying overlay file tree $RD_OVERLAY [0m"

  if [ -d "$RD_OVERLAY" ]; then
		if [ -z "$BIN_RSYNC" ]; then
			cp -au $RD_OVERLAY/* $RD_LAYOUT/
		else
			$BIN_RSYNC -avu $RD_OVERLAY/* $RD_LAYOUT/
		fi
  else
		echo "[1;31mError: no such overlay layout folder[0m"
  fi

  return 0
}

copy_binaries() {

  local bin=""
  local times=0

  echo "[1;36mCopying binaries ...[0m"

  for binary in $BINARIES ; do
		bin="`which $binary`"

		if [ -n "$bin" ]; then
			if [ -e $bin ]; then
        rm -f $RD_LAYOUT/${bin}
				cp -P --parents $bin $RD_LAYOUT/
			else
				echo "[1;35mError: no such binary -- $bin[0m"
			fi
		fi
  done

  for binary in $RD_FILESYSTEMS ; do
		bin="`which mkfs.${binary}`"

		if [ -n "$bin" ]; then
			if [ -e $bin ]; then
        rm -f $RD_LAYOUT/${bin}
				cp -P --parents $bin $RD_LAYOUT/
			else
				echo "[1;35mError: no such binary -- $bin[0m"
			fi
		fi

		bin="`which fsck.${binary}`"

		if [ -n "$bin" ]; then
			if [ -e $bin ]; then
        rm -f $RD_LAYOUT/${bin}
				cp -P --parents $bin $RD_LAYOUT/
			else
				echo "[1;35mError: no such binary -- $bin[0m"
			fi
		fi
	done

  return 0
}

copy_libraries() {

  echo "[1;36mCopying libraries ...[0m"

  # First copy the essential glibc files:
  if [ "`uname -a`" = "x86_64" -o "`uname -a`" = "aarch64" ]; then
    find /lib /lib64 -name "ld-*so*" -o -name "libnss_files*so*" -o -name "libnss_compat*so*" 2> /dev/null | xargs -I'{}' cp -P --parents '{}' $RD_LAYOUT/
  else
    find /lib /lib64 -name "ld-*so*" -o -name "libnss_files*so*" -o -name "libnss_compat*so*" 2> /dev/null | xargs -I'{}' cp -P --parents '{}' $RD_LAYOUT/
  fi

  # Then copy all remaining libs our initrd files link against:
  COUNT=1
  PRFX=$(tempfile --prefix ldd-)
  TMPFILE=${PRFX}${COUNT}

  find $RD_LAYOUT -type f -exec ldd {} 2>/dev/null \; | unify_libs > $TMPFILE

  while [ "$COUNT" != "0" ]; do
    COUNT=$((COUNT+1))

    for i in $(cat ${TMPFILE}) ; do
      ldd $i 2>/dev/null
    done | unify_libs > ${PRFX}${COUNT}

    if [ $(cat $TMPFILE ${PRFX}${COUNT} | sort |uniq -u | wc -l) -eq 0 ]; then
      COUNT=0
    else
      TMPFILE=${PRFX}${COUNT}
    fi

    # emergency eject lever:
    if [ "$COUNT" = "42" ]; then
      COUNT=0
    fi
  done

  for i in $(cat ${PRFX}* | sort -u) ; do 
    cp -P --parents ${i}* $RD_LAYOUT
  done

  ( 
    cd $RD_LAYOUT
    for i in $(find -L . -type l -exec readlink -m /{} \; 2>/dev/null ) ; do
      cp -P --parents ${i} $RD_LAYOUT
    done 
  )

  rm ${PRFX}*
  return 0
}

copy_modules() {

  echo "[1;33mCopying kernel modules ...[0m"

  if grep -q "#modprobe reiserfs" $RD_LAYOUT/bin/rd.modprobe.sh ; then
		rm -f $RD_LAYOUT/bin/rd.modprobe.sh
		touch $RD_LAYOUT/bin/rd.modprobe.sh
		chmod 755 $RD_LAYOUT/bin/rd.modprobe.sh
		echo "# This is a script used to load the kernel modules." >> $RD_LAYOUT/bin/rd.modprobe.sh
		echo "# To use it, chmod it 755, and then add the insmod" >> $RD_LAYOUT/bin/rd.modprobe.sh
		echo "# lines needed to load your modules, like this:" >> $RD_LAYOUT/bin/rd.modprobe.sh
		echo >> $RD_LAYOUT/bin/rd.modprobe.sh
  fi

  # Sanitize the modules list first, before any further processing.
  # The awk command eliminates doubles without changing the order:
  RD_MODULES=$(echo ${RD_MODULES} |tr -s ':' '\n' |awk '!x[$0]++' |tr '\n' ':')
  RD_MODULES=$(echo ${RD_MODULES%:}) # Weed out a trailing ':'

  # Count number of modules
  # This INDEX number gives us an easy way to find individual
  # modules and their arguments, as well as tells us how many
  # times to run through the list
  if ! echo ${RD_MODULES} | grep ':' > /dev/null ; then  # only 1 module specified
		INDEX=1
	else
		# Trim excess ':' which will screw this routine:
		RD_MODULES=$(echo ${RD_MODULES} | tr -s ':')
		INDEX=1

		while [ ! "$(echo "${RD_MODULES}" | cut -f $INDEX -d ':' )" = "" ]; do
			INDEX=$(expr $INDEX + 1)
		done

		INDEX=$(expr $INDEX - 1)      # Don't include the null value
	fi

	# Wrap everything in a while loop
	i=0

	while [ $i -ne $INDEX ]; do
		i=$(( $i + 1 ))
		
		# FULL_MOD is the module plus any arguments (if any)
		# MODULE is the module name
		# ARGS is any optional arguments to be passed to the kernel
		FULL_MOD="$(echo "${RD_MODULES}" | cut -d ':' -f $i)"
		MODULE="$(echo "$FULL_MOD" | cut -d ' ' -f 1 )"

		# Test for arguments
		if echo "$FULL_MOD" | grep ' ' > /dev/null; then
			ARGS=" $(echo "$FULL_MOD" | cut -d ' ' -f 2- )"
		else
			unset ARGS
		fi

		# Get MODULE deps and prepare modprobe lines
		/sbin/modprobe --set-version $RD_KVER --show-depends \
			--ignore-install $MODULE 2>/dev/null | \
			grep "^insmod " | cut -f 2 -d ' ' | while read SRCMOD; do

		if ! grep -Eq " $(basename $SRCMOD .ko)(\.| |$)" $RD_LAYOUT/bin/rd.modprobe.sh 2>/dev/null ; then
			LINE="$(echo "modprobe -v $(basename ${SRCMOD%%.gz} .ko)" )"

			# Test to see if arguments should be passed
			# Over-ride the previously defined LINE variable if so
			if [ "$(basename $SRCMOD .ko)" = "$MODULE" ]; then
				# SRCMOD and MODULE are same, ARGS can be passed
				LINE="$LINE$ARGS"
			fi
		fi

		if ! grep -qx "$LINE" $RD_LAYOUT/bin/rd.modprobe.sh ; then
			echo "$LINE" >> $RD_LAYOUT/bin/rd.modprobe.sh
		fi

		# Try to add the module to the initrd-tree.  This should be done
		# even if it exists there already as we may have changed compilers
		# or otherwise caused the modules in the initrd-tree to need
		# replacement.
		if cp -a --parents $SRCMOD $RD_LAYOUT 2>/dev/null; then

			echo "OK: $SRCMOD added."

			# If a module needs firmware, copy that too
			/sbin/modinfo -F firmware "$SRCMOD" | sed 's/^/\/lib\/firmware\//' |
				while read SRCFW; do
					if cp -a --parents "$SRCFW" $RD_LAYOUT 2>/dev/null; then
						echo "OK: $SRCFW added."
					else
						echo "WARNING:  Could not find firmware \"$SRCFW\""
					fi
				done
			else
				echo "WARNING:  Could not find module \"$SRCMOD\""
			fi
		done
	done

  # Pregenerate the module dependency information
  echo "[1;36mPregenerating module dependency information ...[0m"
  depmod -a -b $RD_LAYOUT ${RD_KVER}

  return 0
}

copy_modconf() {

  mkdir -p $RD_LAYOUT/etc || exit 1
  mkdir -p $RD_LAYOUT/lib || exit 1

  cp -a /etc/modprobe.d $RD_LAYOUT/etc/
	cp -a /lib/modprobe.d $RD_LAYOUT/lib/

  return 0
}

enable_udev() {

  BINARIES="$BINARIES udevadm udevd"

  cp -a /lib/udev $RD_LAYOUT/lib/
  cp /sbin/udev* $RD_LAYOUT/sbin/

  # But we don't want all of /lib/udev
  for file in $(echo $LIBUDEV_BLACKLIST) ; do
    # Replace with a null script (avoids error spew):
    cat << EOF > $RD_LAYOUT/lib/udev/$file
#!/bin/ash
# This space is intentionally left blank
EOF
  done

  return 0
}

enable_btrfs() {

  echo "[1;36mEnabling filesystem btrfs ...[0m"
  BINARIES="$BINARIES btrfs"

  mkdir -p $RD_LAYOUT/sbin || exit 1

  if [ -r /sbin/btrfs ]; then
    cp /sbin/btrfs $RD_LAYOUT/sbin/btrfs
    chmod 0755 $RD_LAYOUT/sbin/btrfs
    RD_MODULES="${RD_MODULES}:btrfs"
  else
    echo "[1;31mError:  btrfs binary is missing, Btrfs support not installed ![0m"
  fi

  return 0
}

enable_raid() {

  local MDADM=$(which mdadm)
  local MDMON=$(which mdmon)

  echo "[1;36mEnabling RAID subsystem ...[0m"
  BINARIES="$BINARIES mdadm mdmon"
  RD_CMDLINE="$RD_CMDLINE rd.raid"

  if [ -n "$MDADM" -a -e $MDADM ]; then
	cp $MDMON $RD_LAYOUT/sbin/mdmon
	chmod 0755 $RD_LAYOUT/sbin/mdmon
  else
	echo "[1;31mError: mdmon binary is missing, RAID support not installed[0m"
	return 1
  fi

  mkdir -p $RD_LAYOUT/sbin || exit 1
  mkdir -p $RD_LAYOUT/lib/udev/rules.d || exit 1

  if [ -n "$MDADM" -a -e $MDADM ]; then

	cp $MDADM $RD_LAYOUT/sbin/mdadm
	chmod 0755 $RD_LAYOUT/sbin/mdadm

    if [ -z "${RD_MODULES}" ] ; then
      RD_MODULES="dm-mod"
    elif ! echo ${RD_MODULES} | grep -q dm-mod ; then
      RD_MODULES="$RD_MODULES:dm-mod"
    fi

	echo 'KERNEL=="dm-[0-9]*", OPTIONS+="db_persist"' > \
	  $RD_LAYOUT/lib/udev/rules.d/95-dm-initrd.rules
	if [ -r /etc/mdadm.conf ] ; then
	  cp /etc/mdadm.conf $RD_LAYOUT/etc
	fi
  else
	echo "[1;31mError: mdadm binary is missing, RAID support not installed[0m"
  fi

  return 0
}

enable_lvm() {

  local LVM=$(which lvm)
  local DMSETUP=$(which dmsetup)

  echo "[1;36mEnabling LVM subsystem ...[0m"
  BINARIES="$BINARIES lvm dmsetup multipath"
  RD_CMDLINE="$RD_CMDLINE rd.lvm"

  mkdir -p $RD_LAYOUT/sbin || exit 1
  mkdir -p $RD_LAYOUT/lib/udev/rules.d || exit 1

  if [ -z "$LVM" ]; then
    LVM=$(which lvm2)
  fi

  if [ -n "$DMSETUP" -a -e $DMSETUP ]; then
    cp $DMSETUP $RD_LAYOUT/sbin/dmsetup
  else
    echo "[1;31mError: dmsetup binary is missing, LVM support isn't installed ![0m"
	return 1
  fi

  if [ -n "$LVM" -a -e $LVM ]; then

    cp $LVM $RD_LAYOUT/sbin/lvm

    find /lib /lib64 -name "libdevmapper*so*" 2> /dev/null | xargs -I'{}' cp -P --parents '{}' $RD_LAYOUT/
    ( cd $RD_LAYOUT/sbin
      ln -s lvm vgchange 2>/dev/null
      ln -s lvm vgscan 2>/dev/null )

    if [ -z "${RD_MODULES}" ] ; then
      RD_MODULES="dm-mod"
    elif ! echo ${RD_MODULES} | grep -q dm-mod ; then
      RD_MODULES="$RD_MODULES:dm-mod"
    fi

    echo 'KERNEL=="dm-[0-9]*", OPTIONS+="db_persist"' > \
			$RD_LAYOUT/lib/udev/rules.d/95-dm-initrd.rules
  else
    echo "[1;31mError: lvm binary is missing, LVM support isn't installed ![0m"
  fi

  return 0
}

badconf_file() {
  # This won't really help with what's *wrong* with the file,
  # but it will at least give them a clue that there's a problem
  echo "[1;31m/etc/mistral/initrd.conf is bad or does not exist.[0m"
  exit 1
}

enable_openrc() {
  RD_CMDLINE="$RD_CMDLINE rd.openrc"
  echo "[1;36mEnabling OpenRC init system ...[0m"
  echo "yes" > $RD_LAYOUT/etc/rd.conf/openrc
  return 0
}

enable_vfatfs() {

  echo "[1;36mEnabling VFat filesystem ...[0m"

  # Several extra modules are needed to support a vfat formatted USB stick...
  # assuming here we are using a western codepage.
  # This possibly adds doublures, but we clean up the MODULE_LIST further down!
  if ! echo ${RD_MODULES} | grep -q vfat ; then
		RD_MODULES="${RD_MODULES}:ehci-hcd:uhci-hcd:usb-storage:hid:usbhid"
		RD_MODULES="${RD_MODULES}:nls_cp437:nls_iso8859-1:msdos:fat:vfat"
  fi

  # This possibly adds doublures, but we clean up the MODULE_LIST further down!
  if ! echo ${RD_MODULES} | grep -q usb_storage ; then
		RD_MODULES="$RD_MODULES:scsi_mod:sd_mod:sr_mod:dm-mod:dm-crypt:usbhid:usb_storage"
		RD_MODULES="$RD_MODULES:ehci-hcd:uhci-hcd:xhci-hcd:ehci-pci:usbhid:hid_generic"
  fi

  return 0
}

enable_efifs() {

  echo "[1;36mEnabling EFI kernel modules ...[0m"

  if [ -z "${RD_MODULES}" ] ; then
		RD_MODULES="efivarfs:efi-pstore"
  elif ! echo ${RD_MODULES} | grep -q efivarfs ; then
		RD_MODULES="$RD_MODULES:efivarfs:efi-pstore"
  fi

  enable_vfatfs

  return 0
}

enable_luks() {

  BINARIES="$BINARIES cryptsetup"

  if echo "$RD_LUKSKEY" | grep -qiF 'LABEL' ; then
	  RD_CMDLINE="$RD_CMDLINE rd.luks=auto"
  elif echo "$RD_LUKSDEV" | grep -qiF 'LABEL' ; then
	  RD_CMDLINE="$RD_CMDLINE rd.luks=auto"
	else
	  RD_CMDLINE="$RD_CMDLINE rd.luks"
	fi

  echo "[1;36mEnabling LUKS encryption ...[0m"
  mkdir -p $RD_LAYOUT/sbin || exit 1

  if [ -n "$BIN_CRYPT" -a -e $BIN_CRYPT ]; then
    cp $BIN_CRYPT $RD_LAYOUT/sbin/cryptsetup

    if [ ! -e $RD_LAYOUT/sbin/udevadm ]; then
      cat << EOF > $RD_LAYOUT/sbin/udevadm
#!/bin/sh
sleep 3
EOF
      chmod 0755 $RD_LAYOUT/sbin/udevadm
    fi

    if [ -z "${RD_MODULES}" ] ; then
      RD_MODULES="dm-mod"
    elif ! echo ${RD_MODULES} | grep -q dm-mod ; then
      RD_MODULES="${RD_MODULES}:dm-mod"
    fi

    if [ -n "$RD_LUKSDEV" ]; then
      # Write the list of LUKS devices to the initrd-tree:
    	echo $RD_LUKSDEV > $RD_LAYOUT/etc/rd.conf/luksdev
		fi

  	if [ -n "$RD_LUKSKEY" ]; then
  	  # Finally, write the LUKS keys to the initrd-tree:
     	echo $RD_LUKSKEY > $RD_LAYOUT/etc/rd.conf/lukskey
    fi
  else
    echo "[1;31mCryptsetup binary is missing, CRYPT support isn't installed ![0m"
  fi

  enable_vfatfs

  return 0
}

enable_fbsplash() {

  echo "[1;36mEnabling frame buffer boot splash ...[0m"

  RD_CMDLINE="$RD_CMDLINE rd.splash=fbsplash"

  mkdir -p $RD_LAYOUT/etc/fbsplash/themes/ || exit 1
  echo "fbsplash" > $RD_LAYOUT/etc/rd.conf/splash

  echo "$1" > $RD_LAYOUT/etc/rd.conf/splash-theme
  echo "$RD_FBSPLASH_SIZE" > $RD_LAYOUT/etc/rd.conf/fbsplash-size

  if [ -z "$BIN_RSYNC" ]; then
    cp -a /usr/share/mistral/fbsplash/* $RD_LAYOUT/etc/fbsplash/themes/
  else
    $BIN_RSYNC -av /usr/share/mistral/fbsplash/* $RD_LAYOUT/etc/fbsplash/themes/
  fi

  RD_MODULES="${RD_MODULES}:vga16fb:vesafb:uvesafb:drm_kms_helper"
  RD_MODULES="${RD_MODULES}:savagefb:nvidiafb:radeonfb"
  return 0
}

enable_mistral() {

  echo "[1;36mEnabling Mistral boot splash ...[0m"

  mkdir -p $RD_LAYOUT/etc/mistral || exit 1
  mkdir -p $RD_LAYOUT/usr/share/mistral || exit 1

  echo "mistral" > $RD_LAYOUT/etc/rd.conf/splash
  echo "$1" > $RD_LAYOUT/etc/rd.conf/splash-theme

  echo "Theme=$1" > $RD_LAYOUT/etc/mistral/theme
  echo "Size=$RD_FBSPLASH_SIZE" >> $RD_LAYOUT/etc/mistral/theme

  if [ -z "$BIN_RSYNC" ]; then
    cp -a /usr/share/mistral/themes $RD_LAYOUT/usr/share/mistral/
  else
    $BIN_RSYNC -av /usr/share/mistral/themes $RD_LAYOUT/usr/share/mistral/
  fi

  RD_MODULES="${RD_MODULES}:vga16fb:vesafb:uvesafb:drm_kms_helper"
  RD_MODULES="${RD_MODULES}:savagefb:nvidiafb:radeonfb"
  return 0
}

enable_plymouth() {

  RD_CMDLINE="$RD_CMDLINE rd.splash=plymouth"
  echo "[1;36mEnabling Plymouth boot splash ...[0m"

  mkdir -p $RD_LAYOUT/etc/plymouth || exit 1
  echo "plymouth" > $RD_LAYOUT/etc/rd.conf/splash

  echo "[Daemon]" > $RD_LAYOUT/etc/plymouth/plymouth.conf
  echo "Theme=$1" >> $RD_LAYOUT/etc/plymouth/plymouth.conf

  echo "[1;31mError: plymouth overlay tree missing ![0m"
  echo "[1;33mTrying to find copy on current host ![0m"
	find /usr/share/plymouth/ /usr/libexec/plymouth/ \
   	/usr/lib/libply* /usr/lib64/libply* \
   	/usr/bin/plymouth* /usr/sbin/plymouth* \
   	2> /dev/null | xargs -I'{}' cp -P --parents '{}' $RD_LAYOUT/

  RD_MODULES="${RD_MODULES}:vga16fb:vesafb:uvesafb:drm_kms_helper"
  RD_MODULES="${RD_MODULES}:savagefb:nvidiafb:radeonfb"
  RD_MODULES="${RD_MODULES}:drm:i915:intel-agp:amd64-agp"

  return 0
}

check_opt() {

  if [ -z "$2" ]; then
		echo "[1;31mInvalid or missing argument to option '$1' ![0m"
		exit 1
  fi

  if [ "x${3}" = "xsystem/folder" ]; then
    if [ ! -d $2 ]; then
	  	echo "[1;31mInvalid folder argument for '$1' ![0m"
			exit 1
		fi
  elif [ -n "$3" ]; then
    if ! echo "$2" | egrep -q "$3" ; then
			echo "[1;31mInvalid argument for option '$1' ![0m"
			exit 1
		fi
	fi

  return 0
}

# If --help is given, print_usage and exit:
if echo $* | egrep -wq '\--help|-h' ; then
  print_usage
  exit 0
fi

# If -v given, print version and exit:
if echo $* | grep -wq '\-v' ; then
  echo "mistral version $MKINITRD_VERSION"
  exit 0
fi

# An prefix for the initrd archive
RD_PFX="breezeos"

# The initrd requires udev to function correctly:
RD_UDEV="yes"

# Parse the config file for options first, the other command line
# options can override the ones set in /etc/mistral/initrd.conf. 
if [ -e /etc/mistral/initrd.conf ]; then
  . /etc/mistral/initrd.conf || badconf_file
else
  badconf_file
fi

# Default values if these aren't previously set.
RD_LAYOUT=${RD_LAYOUT:-"/var/cache/mistral/initrd-tree"}

RD_BUSYBOX=${RD_BUSYBOX:-"/var/cache/mistral/busybox-tree"}

RD_ARCH=${RD_ARCH:-"$(uname -m)"}

RD_KVER=${RD_KVER:-"$(uname -r)"}

RD_FILESYSTEMS=${RD_FILESYSTEMS:-"ext2 ext3 ext4 vfat"}

# We need a sensible default for this special case:
RD_OUTPUT=${RD_OUTPUT:-"/boot/initramfs-${RD_PFX}-${RD_KVER}-${RD_ARCH}.img"}

# Parse options:
while [ ! -z "$1" ]; do
  case $1 in
    -y)
      ASSUME_YES="yes"
      shift
      ;;
    -c)
      RD_CLEAR="yes"
      shift
      ;;
    -C)
      RD_CRYPT="yes"
      RD_LVM="yes"
      RD_RAID="yes"
      shift
      ;;
    -E)
      RD_EFI="yes"
      shift
      ;;
    -m)
      RD_MODCONF="yes"
      shift
      ;;
    -U)
      RD_UDEV="yes"
      shift
      ;;
    -L)
      RD_LVM="yes"
      shift
      ;;
    -R)
      RD_RAID="yes"
      shift
      ;;
    -b)
      RD_BTRFS="yes"
      shift
      ;;
    -O)
      RD_OPENRC="yes"
      shift
      ;;
    -f)
	  	check_opt "$1" "$2"
      RD_ROOTFS="$2"
      shift 2
      ;;
    -r)
	  	check_opt "$1" "$2"
      RD_ROOTDEV="$2"
      shift 2
      ;;
    -k)
	  	check_opt "$1" "$2"
      RD_KVER="$2"
      shift 2
      ;;
    -l)
	  	check_opt "$1" "$2"
      RD_KEYMAP="$2"
      shift 2
      ;;
    -H)
	  	check_opt "$1" "$2"
      RD_RESUME="$2" 
      shift 2
      ;;
    -P)
	  	check_opt "$1" "$2"
      RD_PFX="$2" 
      shift 2
      ;;
    -F)
			check_opt "$1" "$2"
			if [ -z "$RD_FILESYSTEMS" ] ; then
				RD_FILESYSTEMS="`echo "$2" | tr -s ':' ' '`"
			else
				RD_FILESYSTEMS="${RD_FILESYSTEMS}:`echo "$2" | tr -s ':' ' '`"
			fi
      shift 2
      ;;
    -M)
			check_opt "$1" "$2"
			if [ -z "$RD_MODULES" ] ; then
				RD_MODULES="`echo "$2" | tr -s ' ' ':'`"
			else
				RD_MODULES="${RD_MODULES}:`echo "$2" | tr -s ' ' ':'`"
			fi
      shift 2
      ;;
    -o)
      # canonicalize filename:
	  	check_opt "$1" "$2"
      RD_OUTPUT="$(readlink -m $2)"
      shift 2
      ;;
    -s)
      # canonicalize filename:
	  	check_opt "$1" "$2"
      RD_LAYOUT="$(readlink -m $2)"
      shift 2
      ;;
    -S)
	  	check_opt "$1" "$2"
      RD_SPLASH="$2"
      shift 2
      ;;
    -T)
	  	check_opt "$1" "$2"
      RD_SPLASH_THEME="$2"
      shift 2
      ;;
    -V)
	  	check_opt "$1" "$2" "system/folder"
      RD_OVERLAY="$2"
      shift 2
      ;;
    -K)
	  	check_opt "$1" "$2"
      RD_LUKSKEY="$2"
      shift 2
      ;;
    -D)
	  	check_opt "$1" "$2"
      RD_LUKSDEV="$2"
      shift 2
      ;;
    -Z)
	  	check_opt "$1" "$2" "^(gzip|xz)$"
	  	BIN_ZIP="`which $2`"
      shift 2
	  ;;
    -N)
	  	check_opt "$1" "$2"
	  	MKINITRD_NAME="$2"
      shift 2
	  ;;
    *) # unknown, prevent infinite loop
      shift
      ;;
  esac
done

# If RD_LUKSKEY was set, then set RD_CRYPT=1
[ -n "$RD_LUKSKEY" ] && RD_CRYPT="yes" && RD_LVM="yes" && RD_RAID="yes"

# If RD_LUKSDEV was set, then set RD_CRYPT=1
[ -n "$RD_LUKSDEV" ] && RD_CRYPT="yes" && RD_LVM="yes" && RD_RAID="yes"

# If BIN_ZIP was not set, then set it to gzip1
[ -z "$BIN_ZIP" ] && BIN_ZIP="gzip"

# If BIN_ZIP was not set, then set it to gzip1
[ -z "$MKINITRD_NAME" ] && MKINITRD_NAME="BreezeOS Initrd"

if [ "$RD_PFX" != "breezeos" ]; then
	RD_OUTPUT="/boot/initramfs-${RD_PFX}-${RD_KVER}-${RD_ARCH}.img"
fi

# If kernel modules are needed but the kernel version is absent, exit now:
if [ ! -d /lib/modules/$RD_KVER ]; then
  echo "[1;31m;Error: No /lib/modules/$RD_KVER kernel modules tree found ![0m"
  exit 1
fi

# If clearing source tree was requested, do that first
if [ "$RD_CLEAR" = "1" -o "$RD_CLEAR" = "yes" ]; then
  if ! clear_source_tree ; then
	 exit 1
  fi
fi

# If there's no ramdisk layout, make one now:
if [ ! -d "$RD_LAYOUT" ]; then
  if prompt_yesno "About to create the initrd tree" ; then
  	create_source_tree
  else
	 exit 1
  fi
fi

# If $RD_ROOTDEV and $RD_ROOTFS are not set, assume we want the
# values for the currently mounted /
# (unless we find that values are already set in the initrd-tree):
if [ -z "$RD_ROOTDEV" -a -z "$(cat $RD_LAYOUT/rootdev 2>/dev/null)" ]; then
  RD_ROOTDEV=$(mount | grep ' on / ' | cut -f 1 -d ' ')

  if [ "$RD_ROOTDEV" = "/dev/root" ]; then # find real root device
    RD_ROOTDEV="/dev/$(readlink /dev/root)"
  fi

  if ! prompt_yesno "Warning: Assuming root device is '$RD_ROOTDEV'" ; then
    exit 1
  fi
fi

if echo "$RD_ROOTDEV" | grep -qF "/dev/mapper/" ; then
  RD_CRYPT="yes"
  RD_LVM="yes"
  RD_RAID="yes"
  RD_LUKSUUID=$($BIN_LSBLK -sn -lo UUID $RD_ROOTDEV | tr '\n' ' ' | cut -f2 -d' ')
  RD_ROOTUUID=$($BIN_BLKID -s UUID $RD_ROOTDEV | cut -f2 -d' ')
else
  RD_ROOTUUID=$($BIN_BLKID -s UUID $RD_ROOTDEV | cut -f2 -d' ')
fi

if [ -z "$RD_ROOTFS" -a -z "$(cat $RD_LAYOUT/rootfs 2>/dev/null)" ]; then
  RD_ROOTFS=$(mount | grep ' on / ' | cut -f 5 -d ' ')

  if ! prompt_yesno "Warning: Assuming root filesystem type is $RD_ROOTFS" ; then
    exit 1
  fi
fi

if [ -n "$RD_ROOTDEV" ]; then
  echo $RD_ROOTDEV > $RD_LAYOUT/etc/rd.conf/rootdev
else
  echo "[1;31mError: No root device specified ![0m"
  exit 1
fi

# If needed, write it to the initrd-tree:
if [ -n "$RD_ROOTFS" ]; then
  echo $RD_ROOTFS > $RD_LAYOUT/etc/rd.conf/rootfs
else
  echo "[1;31mError: No root filesystem specified ![0m"
  exit 1
fi

if [ -z "$RD_FILESYSTEMS" ] ; then
	RD_FILESYSTEMS="$ROOTFS"
else
	RD_FILESYSTEMS="$RD_FILESYSTEMS $ROOTFS"
fi

if ! prompt_yesno "Warning: root device '$RD_ROOTUUID'" ; then
 exit 1
fi

if ! prompt_yesno "Warning: root luks uuid '$RD_LUKSUUID'" ; then
 exit 1
fi

if [ -n "$RD_ROOTUUID" ]; then
  echo $RD_ROOTUUID > $RD_LAYOUT/etc/rd.conf/rootuuid
  RD_CMDLINE="root=$RD_ROOTUUID"
else
  echo "[1;31mError: No root device specified ![0m"
  exit 1
fi

if [ -n "$RD_LUKSUUID" ]; then
  echo "$RD_LUKSUUID:luksroot" > $RD_LAYOUT/etc/rd.conf/luksuuid
  RD_CMDLINE="$RD_CMDLINE rd.luks.root=UUID=$RD_LUKSUUID"
elif [ "$RD_CRYPT" = "1" -o "$RD_CRYPT" = "yes" ]; then
  echo "[1;31mError: No LUKS UUID for root device found ![0m"
  exit 1
fi

# If no RD_OUTPUT was specified:
RD_OUTPUT=${RD_OUTPUT:-"/boot/initramfs-${RD_PFX}-${RD_KVER}-${RD_ARCH}.img"}

# Finally, write the image name into the RD_LAYOUT:
#echo "$RD_OUTPUT" > $RD_LAYOUT/etc/rd.conf/initrd-name
echo "$MKINITRD_NAME" > $RD_LAYOUT/etc/rd.conf/initrd-name

# Fill resumedev with the swap partition holding the hibernation image
if [ -n "$RD_RESUME" ]; then
  echo $RD_RESUME > $RD_LAYOUT/etc/rd.conf/resumedev
fi

# Add custom keymap support if one was given
if [ -n "$RD_KEYMAP" ]; then
  echo $RD_KEYMAP > $RD_LAYOUT/etc/rd.conf/keymap
  cp /usr/share/mistral/keymaps.tar.gz $RD_LAYOUT/etc/
fi

if echo "$RD_FILESYSTEMS" | grep -qF vfat ; then
  if ! echo "$RD_MODULES" | grep -qF vfat ; then
		# This possibly adds doublures, but we clean up the MODULE_LIST further down!
		RD_MODULES="scsi_mod:sd_mod:sr_mod:dm-mod:dm-crypt:usbhid:usb_storage"
		RD_MODULES="$RD_MODULES:ehci-hcd:uhci-hcd:xhci-hcd:ehci-pci:usbhid:hid_generic"
		RD_MODULES="$RD_MODULES:usb-storage:hid:nls_cp437:nls_iso8859-1:msdos:fat:vfat"
  fi
fi

FS_MODULES="`echo "$RD_FILESYSTEMS" | tr -s ' ' ':'`"

# Add filesystems to list of modules to load
RD_MODULES="${RD_MODULES}:$FS_MODULES"

# Include OpenRC init support in initrd
if [ "$RD_OPENRC" = "1" -o "$RD_OPENRC" = "yes" ]; then
  enable_openrc
fi

# Include UDEV support in initrd
if [ "$RD_UDEV" = "1" -o "$RD_UDEV" = "yes" ]; then
  enable_udev
fi

# Include Btrfs support in initrd
if [ "$RD_BTRFS" = "1" -o "$RD_BTRFS" = "yes" ]; then
  enable_btrfs
fi

# Include RAID support in initrd
if [ "$RD_RAID" = "1" -o "$RD_RAID" = "yes" ]; then
  enable_raid
fi

# Include LVM support in initrd
if [ "$RD_LVM" = "1" -o "$RD_LVM" = "yes" ]; then
  enable_lvm
fi

# Include EFI partition support in initrd
if [ "$RD_EFI" = "1" -o "$RD_EFI" = "yes" ]; then
  enable_efifs
fi

# Include cryptsetup LUKS support in initrd
if [ "$RD_CRYPT" = "1" -o "$RD_CRYPT" = "yes" ]; then
  enable_luks
fi

if [ "$RD_SPLASH" = "plymouth" ]; then
  enable_plymouth $RD_SPLASH_THEME
fi

if [ "$RD_SPLASH" = "mistral" ]; then
  enable_mistral $RD_SPLASH_THEME
fi

if [ "$RD_SPLASH" = "fbsplash" ]; then
  enable_fbsplash $RD_SPLASH_THEME
fi

# Copy overlay file layout
if [ -n "$RD_OVERLAY" ]; then
  copy_overlay
fi

if [ -n "$BUILD_BUSYBOX" ]; then
	build_busybox
fi

# Make module directory:
if [ ! -d $RD_LAYOUT/lib/modules/$RD_KVER ]; then
  mkdir -p $RD_LAYOUT/lib/modules/$RD_KVER || exit 1
fi

# Copy kmod/modprobe stuff to initrd:
for i in kmod depmod insmod lsmod modinfo modprobe rmmod ; do

  bin=$(which ${i})

  if [ -z "$bin" ]; then
		echo "[1;35mError: no such binary -- ${i}[0m"
		continue
	fi

  if [ -e "$bin" ]; then
    rm -f $RD_LAYOUT/sbin/${bin}
		cp -a $bin $RD_LAYOUT/sbin
	else
		echo "[1;35mError: no such binary -- $bin[0m"
	fi

  BINARIES="$BINARIES ${bin}"
done

BINARIES="$BINARIES blkid lsblk findfs tr cut"

# Make sure modules.builtin and modules.order are there (for kmod):
cp -a /lib/modules/$RD_KVER/modules.builtin $RD_LAYOUT/lib/modules/$RD_KVER
cp -a /lib/modules/$RD_KVER/modules.order $RD_LAYOUT/lib/modules/$RD_KVER

# If an executable $RD_LAYOUT/bin/rd.modprobe.sh already exists, then
# we assume you will want to load the kernel modules mentioned in there.
# This means, you do not have to explicitly add those on the commandline:
if [ -x $RD_LAYOUT/bin/rd.modprobe.sh ]; then
  RD_MODULES="${RD_MODULES}:$(cat $RD_LAYOUT/bin/rd.modprobe.sh | grep '^modprobe' |rev |cut -d/ -f1 |rev |cut -d. -f1)"
fi

# Copy /{etc,lib}/modprobe.d/* if desired
if [ "$RD_MODCONF" = "1" -o "$RD_MODCONF" = "yes" ]; then
  copy_modconf
fi

# Copy the modules into place:
if [ -n "$RD_MODULES" ]; then
  copy_modules
fi

# Copy needed binaries
copy_binaries

# Copy needed libraries
copy_libraries

# Make sure all libraries have symlinks:
/sbin/ldconfig $(readlink -f $RD_LAYOUT)/lib/ 2> /dev/null
/sbin/ldconfig $(readlink -f $RD_LAYOUT)/lib64/ 2> /dev/null
/sbin/ldconfig

# And finally, build the initrd:
build_initrd_image

exit 0
