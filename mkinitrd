#!/bin/bash
#
# Copyright 2017  Tsert.Inc, All Rights Reserved
# Copyright 2017  Pierre Innocent, All Rights Reserved
# Copyright 2004  Slackware Linux, Inc., Concord, CA, USA
# Copyright 2004  Patrick J. Volkerding, Concord, CA, USA
# Copyright 2007, 2008, 2009, 2010, 2011  Patrick J. Volkerding, Sebeka, MN, USA
# All rights reserved.
#
# Redistribution and use of this script, with or without modification, is
# permitted provided that the following conditions are met:
#
# 1. Redistributions of this script must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
#  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ''AS IS'' AND ANY EXPRESS OR IMPLIED
#  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
#  EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
#  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
#  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
#  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
#  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
#  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# Modified by Robby Workman <rworkman@slackware.com> 26 November 2007
#   to add support for mkinitrd.conf - No additional license terms added
# Modified by Alan Hicks <alan@slackware.com> 27 November 2007 to enable
#   passing arguments to kernel modules - No additional license terms added
#   volkerdi - feel free to remove these :)
# Modified by Eric Hameleers <alien@slackware.com> 3 April 2008
#   to add support custom keymaps - No additional license terms added
# Modified by Patrick Volkerding <volkerdi@slackware.com> 17 Dec 2008
#   Added support to bail out if kernel modules are requested for a kernel
#   version that is not installed (thanks to Eric Hameleers), be more
#   verbose about showing modules added to the initrd (thanks to
#   Ellington Santos), and if "mount" returns /dev/root as the root device,
#   use readlink to resolve the device pointed to by the /dev/root
#   symlink, changed modprobe to use --ignore-install to avoid catching
#   custom "install" lines and causing /sbin/modprobe to be copied to the
#   initrd (thanks to Ken Milmore).
#   Of course, license terms remain unchanged.
# Modified by Eric Hameleers <alien@slackware.com> 3 March 2010
#   Add lukskey option (-K). Automatically add kernel modules listed in
#   load-kernel-modules if that file is executable.
#   Yada yada yada.
# Modified by Patrick Volkerding <volkerdi@slackware.com> 21 August 2012
#   Add Btrfs multi-device filesystem support option (-b).
#
# Changelog
# 17-May-2019 <dev@breezeos.com>
#  * Modified it to fit an OpenRC installation with Breeze::OS encryption setup.
#
# 17-May-2019 <dev@breezeos.com>
#  * Removed compatibility to a Slackware mkinitrd installation.
#
# 17-Feb-2017 <dev@breezeos.com>
#  * Changed the '-C' option to fit Breeze::OS encryption setup.
#
#############################################################################

PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/libexec"
export PATH

NOCOLORS=false

MKINITRD_VERSION="0.9.0"
MKINITRD_NAME="BreezeOS Initrd"

BIN_ZIP=$(which gzip)
BIN_JAIL=$(which firejail)
BIN_RSYNC=$(which rsync)
BIN_BLKID=$(which blkid)
BIN_LSBLK=$(which lsblk)
BIN_CRYPT=$(which cryptsetup)
BIN_MKSELF="/usr/share/mistral/runself/makeself.sh"
HDR_MKSELF="/usr/share/mistral/runself/makeself-header.sh"

# Don't include these things from /lib/udev/ in the initrd image
LIBUDEV_BLACKLIST="\
  ipod-set-info \
  check-mtp-device \
  check-ptp-camera \
  udev-configure-printer"

print_usage() {
  cat << EOF
Usage: mistral [OPTION]

mistral creates an initial ramdisk (actually an initramfs cpio+gzip
archive) used to load kernel modules that are needed to mount the
root filesystem, or other modules that might be needed before the
root filesystem is available.  Other binaries may be added to the
initrd, and the script is easy to modify.

  -h  Display help message.
  -v  Display version information.
  -c  Clear the existing initrd tree first.
  -y  Assume yes on all questions.

  -b  Build an initrd archive, a runself archive, or busybox <initrd|runself|busybox>.
  -s  Initrd source tree (default /var/cache/mistral/initrd-tree/).

  -k  Kernel version to use.
  -L  Add support for LVM partitions.
  -R  Add support for RAID partitions.
  -C  Add support for LUKS partitions.
  -E  Add support for EFI partitions.
  -J  Add support for Linux jails in runself archives (WIP).
  -U  Include udev in the initrd.

  -f  Filesystem to use for root partition (must be used with -r)
  -r  Root partition device (must be used with -f)
  -o  Output image (default /boot/initramfs-breezeos-<kver>-<arch>.img)
  -l  Custom keymap to load. Like, 'nl' or 'de-latin1-nodeadkeys'
  -m  Add the files in /etc/modprobe.d/ and /lib/modprobe.d/ to the initrd

  -A  Add files to the initrd or runself archive (absolute path only)
  -B  A space delimited list of binaries to be added to the archive.
  -F  A space delimited list of filesystems to add to the initrd.
  -M  A space delimited list of kernel modules to load.
      Additional options may be added to use when loading the
      kernel modules (but in this case the entire list must be
      wrapped with double quotes).  Any dependencies of requested
      modules will also be added to the initrd.
  -H  Device to resume from hibernation. Needs to be the name of
      the swap partition holding the hibernation image.
  -D  A space delimited pair of luks encrypted block devices and
      luks names to be unlocked by the initrd using cryptsetup. All
      devices that must be unlocked in order to access the root
      filesystem must be specified. Can be specified more than once.
      Use with '-r' parameter.
  -K  Use a USB key (fat-formatted) to unlock the root LUKS volume
      The parameter value is filename of a keyfile, as well as the label
      (or uuid) of the partition this file is on.  This way, you can unlock
      your computer automatically if you have a USB stick with your LUKS
      key inserted at boot. A passphrase will still be asked if the LUKS
      key can not be found.
      For example, if your USB thumb drive has a FAT partition with label
      "BRZCRYPTO" and the actual keyfile is called "/keys/breezeos.luks",
      then you need to pass: -K LABEL=BRZCRYPTO:/keys/breezeos.luks
  -P  Specify an initrd prefix, e.g. breezeos.
  -S  Add support for boot splash, .i.e fbsplash or plymouth.
  -T  Specify boot splash theme, .e.g. breezeos, or breezeos:1280x1024.
  -W  Create an initrd image without a root fs or from an existing layout tree.
      options are <noroot> and <wrap> respectively.
  -Z  Specify compression command, i.e. none, gzip or xz.
  -N  Specify the initrd name, 'BreezeOS Initrd'.
  -V  Specify a directory for the overlay file tree.
  -nocolor  Turn color off.

A simple example: Build an initrd for a reiserfs root partition:

  mistral -c -B runself brzpkg, or
  mistral.runself -c brzpkg

A simple example: Build an initrd for a reiserfs root partition:

  mistral -c -F reiserfs

Another example: Build an initrd image using Linux 2.6.35.4-smp kernel
modules for a system with an ext4 root partition on /dev/sdb3:

  mistral -c -k 2.6.35.4-smp -M 'mbcache jbd' -F ext4 -f ext4 -r /dev/sdb3

Note that if you are already logged in with /dev/sdb3 as your /
partition, and it is running ext4, this command works just the same:

  mistral -c -F ext4

EOF
}

crunch() {
  local answer=""
  read answer
  echo "$answer"
  return 0
}

cleanstr() {
  local tokens="$1"
  local answer=""

  if [ "$2" != ":" ]; then
     answer="$(echo "$tokens" | tr -s ' ' '\n' | uniq |tr '\n' ' ')"
  else
     answer="$(echo "$tokens" | tr -s ':' '\n' | uniq |tr '\n' ':')"

	 # Weed out a trailing ':'
	 answer="$(echo ${answer%:})"
  fi

  echo "$answer"
  return 0
}

prompt_yesno() {

  local answer="no"

  if [ "$ASSUME_YES" = "yes" ]; then
  answer="yes"
  else
  echo -n "${1}, ${COLOR_YELLOW}proceed (n/y) [n] ? ${COLOR_OFF}"
  read answer
  fi

  if [ "$answer" = "y" -o "$answer" = "yes" -o "$answer" = "Y" ]; then
    return 0
  fi

  return 1
}

init_colors() {

  if [ -z "$1" ]; then
    COLOR_RED="[1;31m"
    COLOR_GREEN="[1;32m"
    COLOR_YELLOW="[1;33m"
    COLOR_MAGENTA="[1;35m"
    COLOR_CYAN="[1;36m"
    COLOR_OFF="[0m"
  else
    COLOR_RED=""
    COLOR_GREEN=""
    COLOR_YELLOW=""
    COLOR_MAGENTA=""
    COLOR_CYAN=""
    COLOR_OFF=""
  fi

  return 0
}

copy_block_devices() {

  local devices=$(cat /proc/partitions)

  for device in $devices ; do
    if [ ! -r $RD_LAYOUT/dev/$device ]; then
      if [ -b /dev/$device ]; then
        if [ -L /dev/$device ]; then
          cp -a --parents $(readlink -e /dev/$device) $RD_LAYOUT/
        fi

        cp -a --parents /dev/$device $RD_LAYOUT/
      fi
    fi
  done

  return 0
}

clear_source_tree() {
  local answer="no"

  if [ -d "$RD_LAYOUT" ]; then
    if prompt_yesno "About to delete $RD_LAYOUT" ; then
      rm -rf $RD_LAYOUT
    else
      exit 0
    fi
  fi

  return 0
}

create_source_tree() {

  mkdir -p $RD_LAYOUT || exit 1
  mkdir -p $RD_LAYOUT/bin || exit 1
  mkdir -p $RD_LAYOUT/usr/bin || exit 1
  mkdir -p $RD_LAYOUT/usr/lib || exit 1

  if [ "$BUILD_MODE" = "initrd" ]; then
    mkdir -p $RD_LAYOUT/etc/rd.conf || exit 1

    # Make sure a kernel module directory exists:
    mkdir -p $RD_LAYOUT/lib/modules/${RD_KVER} || exit 1

    # Add the initrd-tree skeleton:
    (
     cd $RD_LAYOUT
     tar -xf /usr/share/mistral/initrd-tree.tar.gz
    )

    # Make sure we have any needed block devices
    copy_block_devices
  fi

  if [ -d /lib32 -a -h /lib ]; then
    if [ -d $RD_LAYOUT/lib -a ! -e $RD_LAYOUT/lib64 ]; then
      mv $RD_LAYOUT/lib $RD_LAYOUT/lib64
    fi

    ( cd $RD_LAYOUT ; ln -s lib64 lib )
  fi

  if [ -d /usr/lib32 -a -h /usr/lib ]; then
    if [ -d $RD_LAYOUT/usr/lib -a ! -e $RD_LAYOUT/usr/lib64 ]; then
      mv $RD_LAYOUT/usr/lib $RD_LAYOUT/usr/lib64
    fi

    ( cd $RD_LAYOUT/usr ; ln -s lib64 lib )
  fi

  return 0
}

build_busybox() {
  mkdir -p $RD_BUSYBOX || exit 1

  if [ ! -e /usr/share/mistral/busybox-1.30.1.tar.xz ]; then
	echo "${COLOR_RED}Error: failed to find packaged busybox${COLOR_OFF}"
	return 1
  fi

  # Build the initrd-tree busybox:
  (
    cd $RD_BUSYBOX

    tar -xf /usr/share/mistral/busybox-1.30.1.tar.xz

    make menuconfig && make

    if [ $? = 0 ]; then
      cp busybox $RD_LAYOUT/bin/
    else
      echo "${COLOR_RED}Error: failed to build packaged busybox${COLOR_OFF}"
    fi
  )

  return 0
}

build_runself_archive() {

  local pkgname="$1"
  local pkgpath="$2"
  local pattern="$(echo "$2" |  sed -re 's/[\/]+/\\\//g')"
  local runname="$(basename $RD_OUTPUT)"

  unlink $RD_LAYOUT/$pkgname 2> /dev/null

  cat /usr/share/mistral/runself/dorun.sh | 
    sed -e "s/@pkgpath@/$pattern/g" \
    -e "s/@pkgname@/$pkgname/g" > $RD_LAYOUT/bin/dorun.sh
    chmod a+x $RD_LAYOUT/bin/dorun.sh

  if [ "$RD_OUTPUT" != "$(basename $RD_OUTPUT)" ]; then
    mkdir -p $(dirname $RD_OUTPUT) | exit 1
  fi

  if [ -e "$RD_OUTPUT" ]; then
    echo "${COLOR_CYAN}Saving previous runself archive $RD_OUTPUT ${COLOR_OFF}"
    mv -f $RD_OUTPUT ${RD_OUTPUT}.old
  fi

  # Wrap the runself app as a shell and compressed tar archive
  (
    cd $RD_LAYOUT
    $BIN_MKSELF --noclobber -Z $COMPRESSION \
      --verify $pkgpath \
      --sha512 --sha256 --md5 \
      --target /var/lib/runself/$pkgname \
      --header $HDR_MKSELF \
      --package $LSMFILE \
      --license $LICENSE \
      $RD_LAYOUT \
      $RD_OUTPUT "$LSMTITLE" \
      ./bin/dorun.sh
  )

  echo "${COLOR_GREEN}Created runself archive $runname -- done${COLOR_OFF}"
  return 0
}

build_initrd_image() {

  # Make sure we have any needed block devices
  copy_block_devices

  if [ "$RD_OUTPUT" = "$(basename $RD_OUTPUT)" ]; then
    RD_OUTPUT=/boot/$RD_OUTPUT
  fi

  mkdir -p $(dirname $RD_OUTPUT) || exit 1

  if [ -e "$RD_OUTPUT" ]; then
    echo "${COLOR_CYAN}Saving previous ramdisk $RD_OUTPUT ${COLOR_OFF}"
    mv -f $RD_OUTPUT ${RD_OUTPUT}.old
  fi

  echo "${COLOR_YELLOW}Creating ramdisk $RD_OUTPUT -- done${COLOR_OFF}"

  # Wrap the initrd as an initramfs image and move it into place:
  (
    cd $RD_LAYOUT
    find . | cpio -o -H newc | $BIN_ZIP -9c > $RD_OUTPUT
  )

  RD_CMDLINE="$RD_CMDLINE ro quiet vga=792 net.ifnames=0 console=tty1 consoleblank=0"

  echo "${COLOR_GREEN}Created ramdisk $RD_OUTPUT -- done${COLOR_OFF}"
  echo "${COLOR_YELLOW}Boot cmdline is:${COLOR_OFF}"
  echo "    ${COLOR_CYAN}$RD_CMDLINE${COLOR_OFF}"
  echo "Be sure to update your boot loader !"
  return 0
}

unify_libs() {
  awk '/=. \// { print $3 }' | sort -u
  return 0
}

copy_overlay() {

  for entry in $RD_OVERLAY ; do
    if [ -d "$entry" ]; then
      echo "${COLOR_CYAN}Copying overlay file tree $entry ${COLOR_OFF}"
      if [ -z "$BIN_RSYNC" ]; then
        cp -au $entry/* $RD_LAYOUT/
      else
        $BIN_RSYNC -avu $entry/* $RD_LAYOUT/
      fi
    elif file "$entry" | grep -qF 'compressed data' ; then
      if echo "$entry" | grep -qE '[.]tar[.](gz|xz|bz|bz2)$|[.]t[gxb]z|tbz2$' ; then
        echo "${COLOR_CYAN}Extracting overlay file tree $entry ${COLOR_OFF}"
        tar -C $RD_LAYOUT/ -xf $entry
      elif echo "$entry" | grep -qE '[.]tkg$' ; then
        arcname="$(unzip -l $entry | grep -m1 archive | sed 's/^.*archive/archive/g')"
        if [ "$pkgname" != "archive.sh" ]; then
          echo "${COLOR_CYAN}Extracting overlay file tree $entry ${COLOR_OFF}"
          unzip -p $entry $arcname | tar -C $RD_LAYOUT/ -xf -
        else
          echo "${COLOR_RED}Error: cannot extract a runself onto another runself ${COLOR_OFF}"
        fi
      fi
    else
      echo "${COLOR_RED}Error: no such folder -- $folder ${COLOR_OFF}"
    fi
  done

  return 0
}

copy_additional_files() {

  for path in $RD_ADDFILES ; do
    if [ -n "$path" ]; then
       if [ -e $path ]; then
        rm -f $RD_LAYOUT/${path}
        cp -P --parents $path $RD_LAYOUT/
      else
         echo "${COLOR_MAGENTA}Error: no such file -- $path${COLOR_OFF}"
      fi
    fi
  done

  return 0
}

copy_binaries() {

  local rd_binaries="$(cleanstr "$RD_BINARIES")"
  local rd_filesystems="$(cleanstr "$RD_FILESYSTEMS")"
  local opts="--no-dereference --preserve=all"
  local bin=""

  echo "${COLOR_CYAN}Copying binaries ...${COLOR_OFF}"
  rd_binaries="$rd_binaries mke2fs fsck e2fsck dosfsck fsck-e2fsprogs"

  for binary in $rd_binaries ; do
    bin="`which $binary`"

    if [ -n "$bin" ]; then
      if [ -e $bin ]; then
        echo "${COLOR_YELLOW}Copying binary $bin ...${COLOR_OFF}"
        rm -f $RD_LAYOUT/${bin}
        cp -P --parents $bin $RD_LAYOUT/
        if [ -h $bin ]; then
			bin="$(readlink $bin)"
    		[ -n "$bin" ] && cp -P --parents $bin $RD_LAYOUT/
		fi
      else
        echo "${COLOR_MAGENTA}Error: no such binary -- $bin${COLOR_OFF}"
      fi
    fi
  done

  echo "${COLOR_CYAN}Copying filesystem binaries '$rd_filesystems' ...${COLOR_OFF}"

  for binary in $rd_filesystems ; do
    bin="`which mkfs.${binary}`"

    if [ -n "$bin" ]; then
      if [ -e $bin ]; then
        echo "${COLOR_YELLOW}Copying binary $bin ...${COLOR_OFF}"
        rm -f $RD_LAYOUT/${bin}
        cp -P --parents $bin $RD_LAYOUT/
        if [ -h $bin ]; then
			bin="$(readlink $bin)"
    		[ -n "$bin" ] && cp -P --parents $bin $RD_LAYOUT/
		fi
      else
        echo "${COLOR_MAGENTA}Error: no such binary -- $bin${COLOR_OFF}"
      fi
    fi

    bin="`which fsck.${binary}`"

    if [ -n "$bin" ]; then
      if [ -e $bin ]; then
        echo "${COLOR_YELLOW}Copying binary $bin ...${COLOR_OFF}"
        rm -f $RD_LAYOUT/${bin}
        cp -P --parents $bin $RD_LAYOUT/
        if [ -h $bin ]; then
			bin="$(readlink $bin)"
    		[ -n "$bin" ] && cp -P --parents $bin $RD_LAYOUT/
		fi
      else
        echo "${COLOR_MAGENTA}Error: no such binary -- $bin${COLOR_OFF}"
      fi
    fi
  done

  return 0
}

copy_libraries() {

  local excludes="$1"

  echo "${COLOR_CYAN}Copying libraries ...${COLOR_OFF}"

  # First copy the essential glibc files:
  if [ "$excludes" = "prune" ]; then
#  excludes="/lib/modules/ -prune /lib64/modules -prune"
#  excludes="$excludes /lib/udev/ -prune /lib64/udev -prune"

    find /lib64 /lib -name "ld-*so*" \
      -o -name "libnss_files*so*" \
      -o -name "libnss_compat*so*" | \
      egrep -v '/(lib|lib64)/(modules|udev)/' | \
      xargs -I'{}' cp -P --parents '{}' $RD_LAYOUT/
  else
    find /lib64 /lib -name "ld-*so*" \
      -o -name "libnss_files*so*" \
      -o -name "libnss_compat*so*" | \
      xargs -I'{}' cp -P --parents '{}' $RD_LAYOUT/
  fi

  # Then copy all remaining libs our initrd or runself files link against:
  COUNT=1
  PRFX=$(tempfile --prefix ldd-)
  TMPFILE=${PRFX}${COUNT}

  find $RD_LAYOUT -type f -exec ldd {} 2>/dev/null \; | unify_libs > $TMPFILE

  while [ "$COUNT" != "0" ]; do
    COUNT=$((COUNT+1))

    for i in $(cat ${TMPFILE}) ; do
      ldd $i 2>/dev/null
    done | unify_libs > ${PRFX}${COUNT}

    if [ $(cat $TMPFILE ${PRFX}${COUNT} | sort |uniq -u | wc -l) -eq 0 ]; then
      COUNT=0
    else
      TMPFILE=${PRFX}${COUNT}
    fi

    # emergency eject lever:
    if [ "$COUNT" = "42" ]; then
      COUNT=0
    fi
  done

  for i in $(cat ${PRFX}* | sort -u) ; do 
    cp -P --parents ${i}* $RD_LAYOUT
  done

  ( 
    cd $RD_LAYOUT
    for i in $(find -L . -type l -exec readlink -m /{} \; 2>/dev/null ) ; do
      cp -P --parents ${i} $RD_LAYOUT
    done 
  )

  rm ${PRFX}*
  return 0
}

copy_modules() {

  local rd_modules="$(cleanstr "$RD_MODULES" ':')"

  echo "${COLOR_YELLOW}Copying kernel modules ...${COLOR_OFF}"

  if grep -q "#modprobe reiserfs" $RD_LAYOUT/bin/rd.modprobe.sh ; then
    rm -f $RD_LAYOUT/bin/rd.modprobe.sh
    touch $RD_LAYOUT/bin/rd.modprobe.sh
    chmod 755 $RD_LAYOUT/bin/rd.modprobe.sh
    echo "# This is a script used to load the kernel modules." >> $RD_LAYOUT/bin/rd.modprobe.sh
    echo "# To use it, chmod it 755, and then add the insmod" >> $RD_LAYOUT/bin/rd.modprobe.sh
    echo "# lines needed to load your modules, like this:" >> $RD_LAYOUT/bin/rd.modprobe.sh
    echo >> $RD_LAYOUT/bin/rd.modprobe.sh
  fi

  # Sanitize the modules list first, before any further processing.
  # The awk command eliminates doubles without changing the order:
  #rd_modules=$(echo ${rd_modules} | tr -s ':' '\n' | uniq |tr '\n' ':')
  ##rd_modules=$(echo ${rd_modules} | tr -s ':' '\n' |awk '!x[$0]++' |tr '\n' ':')
  #rd_modules=$(echo ${rd_modules%:}) # Weed out a trailing ':'

  # Count number of modules
  # This INDEX number gives us an easy way to find individual
  # modules and their arguments, as well as tells us how many
  # times to run through the list
  if ! echo ${rd_modules} | grep ':' > /dev/null ; then  # only 1 module specified
    INDEX=1
  else
    # Trim excess ':' which will screw this routine:
    rd_modules=$(echo ${rd_modules} | tr -s ':')
    INDEX=1

    while [ ! "$(echo "${rd_modules}" | cut -f $INDEX -d ':' )" = "" ]; do
      INDEX=$(expr $INDEX + 1)
    done

    INDEX=$(expr $INDEX - 1)      # Don't include the null value
  fi

  # Wrap everything in a while loop
  i=0

  while [ $i -ne $INDEX ]; do
    i=$(( $i + 1 ))
    
    # FULL_MOD is the module plus any arguments (if any)
    # MODULE is the module name
    # ARGS is any optional arguments to be passed to the kernel
    FULL_MOD="$(echo "${rd_modules}" | cut -d ':' -f $i)"
    MODULE="$(echo "$FULL_MOD" | cut -d ' ' -f 1 )"

    # Test for arguments
    if echo "$FULL_MOD" | grep ' ' > /dev/null; then
      ARGS=" $(echo "$FULL_MOD" | cut -d ' ' -f 2- )"
    else
      unset ARGS
    fi

    # Get MODULE deps and prepare modprobe lines
    /sbin/modprobe --set-version $RD_KVER --show-depends \
      --ignore-install $MODULE 2>/dev/null | \
      grep "^insmod " | cut -f 2 -d ' ' | while read SRCMOD; do

    if ! grep -Eq " $(basename $SRCMOD .ko)(\.| |$)" $RD_LAYOUT/bin/rd.modprobe.sh 2>/dev/null ; then
      LINE="$(echo "modprobe -v $(basename ${SRCMOD%%.gz} .ko)" )"

      # Test to see if arguments should be passed
      # Over-ride the previously defined LINE variable if so
      if [ "$(basename $SRCMOD .ko)" = "$MODULE" ]; then
        # SRCMOD and MODULE are same, ARGS can be passed
        LINE="$LINE$ARGS"
      fi
    fi

    if ! grep -qx "$LINE" $RD_LAYOUT/bin/rd.modprobe.sh ; then
      echo "$LINE" >> $RD_LAYOUT/bin/rd.modprobe.sh
    fi

    # Try to add the module to the initrd-tree.  This should be done
    # even if it exists there already as we may have changed compilers
    # or otherwise caused the modules in the initrd-tree to need
    # replacement.
    if cp -a --parents $SRCMOD $RD_LAYOUT 2>/dev/null; then

      echo "OK: $SRCMOD added."

      # If a module needs firmware, copy that too
      /sbin/modinfo -F firmware "$SRCMOD" | sed 's/^/\/lib\/firmware\//' |
        while read SRCFW; do
          if cp -a --parents "$SRCFW" $RD_LAYOUT 2>/dev/null; then
            echo "OK: $SRCFW added."
          else
            echo "WARNING:  Could not find firmware \"$SRCFW\""
          fi
        done
      else
        echo "WARNING:  Could not find module \"$SRCMOD\""
      fi
    done
  done

  # Pregenerate the module dependency information
  echo "${COLOR_CYAN}Pregenerating module dependency information ...${COLOR_OFF}"
  depmod -a -b $RD_LAYOUT ${RD_KVER}

  return 0
}

copy_modconf() {

  mkdir -p $RD_LAYOUT/etc || exit 1
  mkdir -p $RD_LAYOUT/lib || exit 1

  cp -a /etc/modprobe.d $RD_LAYOUT/etc/
  cp -a /lib/modprobe.d $RD_LAYOUT/lib/

  return 0
}

enable_udev() {

  RD_BINARIES="$RD_BINARIES udevadm udevd"

  cp -a /lib/udev $RD_LAYOUT/lib/
  cp /sbin/udev* $RD_LAYOUT/sbin/

  # But we don't want all of /lib/udev
  for file in $(echo $LIBUDEV_BLACKLIST) ; do
    # Replace with a null script (avoids error spew):
    cat << EOF > $RD_LAYOUT/lib/udev/$file
#!/bin/ash
# This space is intentionally left blank
EOF
  done

  return 0
}

enable_raid() {

  local MDADM=$(which mdadm)
  local MDMON=$(which mdmon)

  echo "${COLOR_CYAN}Enabling RAID subsystem ...${COLOR_OFF}"
  RD_BINARIES="$RD_BINARIES mdadm mdmon"
  RD_CMDLINE="$RD_CMDLINE rd.raid"

  if [ -n "$MDADM" -a -e $MDADM ]; then
		cp $MDMON $RD_LAYOUT/sbin/mdmon
		chmod 0755 $RD_LAYOUT/sbin/mdmon
  else
		echo "${COLOR_RED}Error: mdmon binary is missing, RAID support not installed${COLOR_OFF}"
		return 1
  fi

  mkdir -p $RD_LAYOUT/sbin || exit 1
  mkdir -p $RD_LAYOUT/lib/udev/rules.d || exit 1

  if [ -n "$MDADM" -a -e $MDADM ]; then

		cp $MDADM $RD_LAYOUT/sbin/mdadm
		chmod 0755 $RD_LAYOUT/sbin/mdadm

		if [ -z "${RD_MODULES}" ] ; then
			RD_MODULES="dm-mod"
		elif ! echo ${RD_MODULES} | grep -q dm-mod ; then
			RD_MODULES="$RD_MODULES:dm-mod"
		fi

		echo 'KERNEL=="dm-[0-9]*", OPTIONS+="db_persist"' > \
			$RD_LAYOUT/lib/udev/rules.d/95-dm-initrd.rules

		if [ -r /etc/mdadm.conf ] ; then
			cp /etc/mdadm.conf $RD_LAYOUT/etc
		fi
	else
		echo "${COLOR_RED}Error: mdadm binary is missing, RAID support not installed${COLOR_OFF}"
	fi

  return 0
}

enable_lvm() {

  local LVM=$(which lvm)
  local DMSETUP=$(which dmsetup)

  echo "${COLOR_CYAN}Enabling LVM subsystem ...${COLOR_OFF}"
  RD_BINARIES="$RD_BINARIES lvm dmsetup multipath"

  RD_CMDLINE="$RD_CMDLINE rd.lvm"

  mkdir -p $RD_LAYOUT/sbin || exit 1
  mkdir -p $RD_LAYOUT/lib/udev/rules.d || exit 1

  if [ -z "$LVM" ]; then
    LVM=$(which lvm2)
  fi

  if [ -n "$DMSETUP" -a -e $DMSETUP ]; then
    cp $DMSETUP $RD_LAYOUT/sbin/dmsetup
  else
    echo "${COLOR_RED}Error: dmsetup binary is missing, LVM support isn't installed !${COLOR_OFF}"
  return 1
  fi

  if [ -n "$LVM" -a -e $LVM ]; then

    cp $LVM $RD_LAYOUT/sbin/lvm

    find /lib64 /lib -name "libdevmapper*so*" 2> /dev/null | xargs -I'{}' cp -P --parents '{}' $RD_LAYOUT/
    ( cd $RD_LAYOUT/sbin
      ln -s lvm vgchange 2>/dev/null
      ln -s lvm vgscan 2>/dev/null )

    if [ -z "${RD_MODULES}" ] ; then
      RD_MODULES="dm-mod"
    elif ! echo ${RD_MODULES} | grep -q dm-mod ; then
      RD_MODULES="$RD_MODULES:dm-mod"
    fi

    echo 'KERNEL=="dm-[0-9]*", OPTIONS+="db_persist"' > \
      $RD_LAYOUT/lib/udev/rules.d/95-dm-initrd.rules
  else
    echo "${COLOR_RED}Error: lvm binary is missing, LVM support isn't installed !${COLOR_OFF}"
  fi

  return 0
}

badconf_file() {
  # This won't really help with what's *wrong* with the file,
  # but it will at least give them a clue that there's a problem
  echo "${COLOR_RED}/etc/mistral/$1.conf is bad or does not exist.${COLOR_OFF}"
  exit 1
}

enable_openrc() {
  RD_CMDLINE="$RD_CMDLINE rd.openrc"
  echo "${COLOR_CYAN}Enabling OpenRC init system ...${COLOR_OFF}"
  echo "yes" > $RD_LAYOUT/etc/rd.conf/openrc
  return 0
}

enable_vfatfs() {

  echo "${COLOR_CYAN}Enabling VFat filesystem ...${COLOR_OFF}"

  # Several extra modules are needed to support a vfat formatted USB stick...
  # assuming here we are using a western codepage.
  # This possibly adds doublures, but we clean up the MODULE_LIST further down!
  if ! echo ${RD_MODULES} | grep -qE '[v]?fat' ; then
    RD_MODULES="${RD_MODULES}:ehci-hcd:uhci-hcd:usb-storage:hid:usbhid"
    RD_MODULES="${RD_MODULES}:nls_cp437:nls_iso8859-1:msdos:fat:vfat"
  fi

  # This possibly adds doublures, but we clean up the MODULE_LIST further down!
  if ! echo ${RD_MODULES} | grep -q usb_storage ; then
    RD_MODULES="$RD_MODULES:scsi_mod:sd_mod:sr_mod:dm-mod:dm-crypt:usbhid:usb_storage"
    RD_MODULES="$RD_MODULES:ehci-hcd:uhci-hcd:xhci-hcd:ehci-pci:usbhid:hid_generic"
  fi

  return 0
}

enable_efifs() {

  echo "${COLOR_CYAN}Enabling EFI kernel modules ...${COLOR_OFF}"

  if [ -z "${RD_MODULES}" ] ; then
    RD_MODULES="efivarfs:efi-pstore"
  elif ! echo ${RD_MODULES} | grep -q efivarfs ; then
    RD_MODULES="$RD_MODULES:efivarfs:efi-pstore"
  fi

  enable_vfatfs

  return 0
}

enable_luks() {

  RD_BINARIES="$RD_BINARIES cryptsetup"

  if echo "$RD_LUKSKEY" | grep -qiF 'LABEL' ; then
    RD_CMDLINE="$RD_CMDLINE rd.luks=auto"
  elif echo "$RD_LUKSDEV" | grep -qiF 'LABEL' ; then
    RD_CMDLINE="$RD_CMDLINE rd.luks=auto"
  else
    RD_CMDLINE="$RD_CMDLINE rd.luks"
  fi

  echo "${COLOR_CYAN}Enabling LUKS encryption ...${COLOR_OFF}"
  mkdir -p $RD_LAYOUT/sbin || exit 1

  if [ -n "$BIN_CRYPT" -a -e $BIN_CRYPT ]; then
    cp $BIN_CRYPT $RD_LAYOUT/sbin/cryptsetup

    if [ ! -e $RD_LAYOUT/sbin/udevadm ]; then
      cat << EOF > $RD_LAYOUT/sbin/udevadm
#!/bin/sh
sleep 3
EOF
      chmod 0755 $RD_LAYOUT/sbin/udevadm
    fi

    if [ -z "${RD_MODULES}" ] ; then
      RD_MODULES="dm-mod"
    elif ! echo ${RD_MODULES} | grep -q dm-mod ; then
      RD_MODULES="${RD_MODULES}:dm-mod"
    fi

    if [ -n "$RD_LUKSDEV" ]; then
      # Write the list of LUKS devices to the initrd-tree:
      echo $RD_LUKSDEV > $RD_LAYOUT/etc/rd.conf/luksdev
    fi

    if [ -n "$RD_LUKSKEY" ]; then
      # Finally, write the LUKS keys to the initrd-tree:
       echo $RD_LUKSKEY > $RD_LAYOUT/etc/rd.conf/lukskey
    fi
  else
    echo "${COLOR_RED}Cryptsetup binary is missing, CRYPT support isn't installed !${COLOR_OFF}"
  fi

  enable_vfatfs

  return 0
}

enable_fbsplash() {

  echo "${COLOR_CYAN}Enabling frame buffer boot splash ...${COLOR_OFF}"

  RD_CMDLINE="$RD_CMDLINE rd.splash=fbsplash"

  mkdir -p $RD_LAYOUT/etc/fbsplash/themes/ || exit 1
  echo "fbsplash" > $RD_LAYOUT/etc/rd.conf/splash

  echo "$1" > $RD_LAYOUT/etc/rd.conf/splash-theme
  echo "$RD_FBSPLASH_SIZE" > $RD_LAYOUT/etc/rd.conf/fbsplash-size

  if [ -z "$BIN_RSYNC" ]; then
    cp -a /usr/share/mistral/fbsplash/* $RD_LAYOUT/etc/fbsplash/themes/
  else
    $BIN_RSYNC -av /usr/share/mistral/fbsplash/* $RD_LAYOUT/etc/fbsplash/themes/
  fi

  RD_MODULES="${RD_MODULES}:vga16fb:vesafb:uvesafb:drm_kms_helper"
  RD_MODULES="${RD_MODULES}:savagefb:nvidiafb:radeonfb"
  return 0
}

enable_mistral() {

  echo "${COLOR_CYAN}Enabling Mistral boot splash ...${COLOR_OFF}"

  mkdir -p $RD_LAYOUT/etc/mistral || exit 1
  mkdir -p $RD_LAYOUT/usr/share/mistral || exit 1

  echo "mistral" > $RD_LAYOUT/etc/rd.conf/splash
  echo "$1" > $RD_LAYOUT/etc/rd.conf/splash-theme

  echo "Theme=$1" > $RD_LAYOUT/etc/mistral/theme
  echo "Size=$RD_FBSPLASH_SIZE" >> $RD_LAYOUT/etc/mistral/theme

  if [ -z "$BIN_RSYNC" ]; then
    cp -a /usr/share/mistral/themes $RD_LAYOUT/usr/share/mistral/
  else
    $BIN_RSYNC -av /usr/share/mistral/themes $RD_LAYOUT/usr/share/mistral/
  fi

  RD_MODULES="${RD_MODULES}:vga16fb:vesafb:uvesafb:drm_kms_helper"
  RD_MODULES="${RD_MODULES}:savagefb:nvidiafb:radeonfb"
  return 0
}

enable_plymouth() {

  RD_CMDLINE="$RD_CMDLINE rd.splash=plymouth"
  echo "${COLOR_CYAN}Enabling Plymouth boot splash ...${COLOR_OFF}"

  mkdir -p $RD_LAYOUT/etc/plymouth || exit 1
  echo "plymouth" > $RD_LAYOUT/etc/rd.conf/splash

  echo "[Daemon]" > $RD_LAYOUT/etc/plymouth/plymouth.conf
  echo "Theme=$1" >> $RD_LAYOUT/etc/plymouth/plymouth.conf

  echo "${COLOR_RED}Error: plymouth overlay tree missing !${COLOR_OFF}"
  echo "${COLOR_YELLOW}Trying to find copy on current host !${COLOR_OFF}"
  find /usr/share/plymouth/ /usr/libexec/plymouth/ \
     /usr/lib/libply* /usr/lib64/libply* \
     /usr/bin/plymouth* /usr/sbin/plymouth* \
     2> /dev/null | xargs -I'{}' cp -P --parents '{}' $RD_LAYOUT/

  RD_MODULES="${RD_MODULES}:vga16fb:vesafb:uvesafb:drm_kms_helper"
  RD_MODULES="${RD_MODULES}:savagefb:nvidiafb:radeonfb"
  RD_MODULES="${RD_MODULES}:drm:i915:intel-agp:amd64-agp"

  return 0
}

source_initrd_opts() {
  if [ -e /etc/mistral/initrd.conf ]; then
    . /etc/mistral/initrd.conf || badconf_file "initrd"
  else
    badconf_file "initrd"
  fi

  return 0
}

source_runself_opts() {

  RD_LAYOUT="/var/cache/mistral/runself-tree/"

  if [ -e /etc/mistral/runself.conf ]; then
    . /etc/mistral/runself.conf || badconf_file "runself"
  else
    badconf_file "runself"
  fi

  return 0
}

check_opt() {

  if [ -z "$2" ]; then
    echo "${COLOR_RED}Invalid or missing argument to option '$1' !${COLOR_OFF}"
    exit 1
  fi

  if [ "x${3}" = "xsystem/folder" ]; then
    if [ ! -d $2 ]; then
      echo "${COLOR_RED}Invalid folder argument for '$1' !${COLOR_OFF}"
      exit 1
    fi
  elif [ -n "$3" ]; then
    if ! echo "$2" | egrep -q "$3" ; then
      echo "${COLOR_RED}Invalid argument for option '$1' !${COLOR_OFF}"
      exit 1
    fi
  fi

  return 0
}

# If --help is given, print_usage and exit:
if echo $* | egrep -wq '\--help|-h' ; then
  print_usage
  exit 0
fi

# If -v given, print version and exit:
if echo $* | grep -wq '\-v' ; then
  echo "mistral version $MKINITRD_VERSION"
  exit 0
fi

# An prefix for the initrd archive
RD_PFX="breezeos"

# The initrd requires udev to function correctly:
RD_UDEV="yes"

# Default values if these aren't previously set.
RD_LAYOUT=${RD_LAYOUT:-"/var/cache/mistral/initrd-tree"}

COMPRESSION=${COMPRESSION:-"gzip"}

RD_ARCH=${RD_ARCH:-"$(uname -m)"}

RD_KVER=${RD_KVER:-"$(uname -r)"}

# We need a sensible default for this special case:
RD_OUTPUT=${RD_OUTPUT:-"/boot/initramfs-${RD_PFX}-${RD_KVER}-${RD_ARCH}.img"}

# Parse the config file for options first, the other command line
# options can override the ones set in /etc/mistral/initrd.conf. 
if [ "`basename $0`" = "mistral.runself" ]; then
  BUILD_MODE="runself"
  source_runself_opts

elif [ -e /etc/mistral/initrd.conf ]; then
  BUILD_MODE="initrd"
  source_initrd_opts

  RD_FILESYSTEMS=${RD_FILESYSTEMS:-"ext2 ext3 ext4 vfat fat"}
  RD_BUSYBOX=${RD_BUSYBOX:-"/var/cache/mistral/busybox-tree"}

else
  badconf_file "initrd"
fi

RD_WRAP="no"
RD_NOROOT="no"

init_colors

# Parse options:
while [ ! -z "$1" ]; do
  case $1 in
    -y)
      ASSUME_YES="yes"
      shift
      ;;
    -c)
      RD_CLEAR="yes"
      shift
      ;;
    -C)
      RD_CRYPT="yes"
      RD_LVM="yes"
      RD_RAID="yes"
      shift
      ;;
    -E)
      RD_EFI="yes"
      shift
      ;;
    -J)
      RS_JAIL="yes"
      shift
      ;;
    -m)
      RD_MODCONF="yes"
      shift
      ;;
    -U)
      RD_UDEV="yes"
      shift
      ;;
    -L)
      RD_LVM="yes"
      shift
      ;;
    -R)
      RD_RAID="yes"
      shift
      ;;
    -b)
      check_opt "$1" "$2" '^(initrd|runself|busybox)$'
      BUILD_MODE="$2"

      if [ "$BUILD_MODE" = "runself" ]; then
         source_runself_opts
      fi
      shift 2
      ;;
#    -O)
#      RD_OPENRC="yes"
#      shift
#      ;;
    -f)
    check_opt "$1" "$2"
      RD_ROOTFS="$2"
      shift 2
      ;;
    -r)
    check_opt "$1" "$2" "^/dev/"
      RD_ROOTDEV="$2"
      shift 2
      ;;
    -k)
    check_opt "$1" "$2"
      RD_KVER="$2"
      shift 2
      ;;
    -l)
    check_opt "$1" "$2"
      RD_KEYMAP="$2"
      shift 2
      ;;
    -H)
    check_opt "$1" "$2"
      RD_RESUME="$2" 
      shift 2
      ;;
    -P)
    check_opt "$1" "$2"
      RD_PFX="$2" 
      shift 2
      ;;
    -A)
    check_opt "$1" "$2"
      [ -n "$RD_ADDFILES" ] && RD_ADDFILES="$RD_ADDFILES $2"
      [ -z "$RD_ADDFILES" ] && RD_ADDFILES="$2"
      shift 2
      ;;
    -B)
    check_opt "$1" "$2"
      [ -n "$RD_BINARIES" ] && RD_BINARIES="$RD_BINARIES $2"
      [ -z "$RD_BINARIES" ] && RD_BINARIES="$2"
	    RD_BINARIES="$(echo "$RD_BINARIES" | tr -s ':' ' ')"
      shift 2
      ;;
    -F)
    check_opt "$1" "$2"
      [ -n "$RD_FILESYSTEMS" ] && RD_FILESYSTEMS="$RD_FILESYSTEMS $2"
      [ -z "$RD_FILESYSTEMS" ] && RD_FILESYSTEMS="$2"
	    RD_FILESYSTEMS="$(echo "$RD_FILESYSTEMS" | tr -s ':' ' ')"
      shift 2
      ;;
    -M)
    check_opt "$1" "$2"
      [ -n "$RD_MODULES" ] && RD_MODULES="$RD_MODULES $2"
      [ -z "$RD_MODULES" ] && RD_MODULES="$2"
	    RD_MODULES="$(echo "$RD_MODULES" | tr -s ' ' ':')"
      shift 2
      ;;
    -V)
      check_opt "$1" "$2" "system/folder"
      [ -n "$RD_OVERLAY" ] && RD_OVERLAY="$RD_OVERLAY $2"
      [ -z "$RD_OVERLAY" ] && RD_OVERLAY="$2"
      shift 2
      ;;
    -o)
      # canonicalize filename:
    check_opt "$1" "$2"
      RD_OUTPUT_FORCE="$(readlink -m $2)"
      shift 2
      ;;
    -s)
      # canonicalize filename:
    check_opt "$1" "$2"
      RD_LAYOUT="$(readlink -m $2)"
      shift 2
      ;;
    -S)
    check_opt "$1" "$2"
      RD_SPLASH="$2"
      shift 2
      ;;
    -T)
      check_opt "$1" "$2"
      RD_SPLASH_THEME="$2"
      shift 2
      ;;
    -K)
      check_opt "$1" "$2"
      RD_LUKSKEY="$2"
      shift 2
      ;;
    -D)
      check_opt "$1" "$2"
      RD_LUKSDEV="$2"
      shift 2
      ;;
    -N)
      check_opt "$1" "$2"
      MKINITRD_NAME="$2"
      shift 2
    ;;
    -Z|--zip)
      check_opt "$1" "$2" "^(gzip|xz|bzip2|none)$"
      BIN_ZIP="`which $2`"
      COMPRESSION="$2"
      shift 2
    ;;
    -W)
      check_opt "$1" "$2" "^(create|wrap|noroot)$"
      if [ "$2" = "wrap" ]; then
        RD_WRAP="1"
      elif [ "$2" = "noroot" ]; then
        RD_NOROOT="1"
      fi
      shift 2
      ;;
    -nocolor|-nc)
      NOCOLORS=true
      shift 1
    ;;
    *)
      if [ "$BUILD_MODE" = "runself" ]; then
        [ -z "$PKGNAME" ] && PKGNAME="$1"
        [ -n "$RD_BINARIES" ] && RD_BINARIES="$RD_BINARIES $1"
        [ -z "$RD_BINARIES" ] && RD_BINARIES="$1"
      else # unknown, prevent infinite loop
        echo "${COLOR_YELLOW}Invalid argument $1 !"
        exit 1
      fi
      shift
      ;;
  esac
done

#====== Starts here ======#

[ "$NOCOLORS" = true ] && init_colors "no"

[ -z "$MKINITRD_NAME" ] && MKINITRD_NAME="BreezeOS Initrd"

# If RD_LUKSKEY was set, then set RD_CRYPT=1
[ -n "$RD_LUKSKEY" ] && RD_CRYPT="yes" && RD_LVM="yes" && RD_RAID="yes"

# If RD_LUKSDEV was set, then set RD_CRYPT=1
[ -n "$RD_LUKSDEV" ] && RD_CRYPT="yes" && RD_LVM="yes" && RD_RAID="yes"

# If BIN_ZIP was not set, then set it to gzip
[ -z "$BIN_ZIP" ] && BIN_ZIP="gzip"

if [ "$BUILD_MODE" = "busybox" ]; then
  exec build_busybox

elif [ "$BUILD_MODE" = "initrd" ]; then
  if ! prompt_yesno "Using kernel version $RD_KVER" ; then
   exit 1
  fi

  if [ -n "$RD_OUTPUT_FORCE" ]; then
    RD_OUTPUT="$RD_OUTPUT_FORCE"
  else
    RD_OUTPUT="/boot/initramfs-${RD_PFX}-$RD_KVER-${RD_ARCH}.img"
  fi

  if ! prompt_yesno "Using output initrd $RD_OUTPUT" ; then
   exit 1
  fi

  # If kernel modules are needed but the kernel version is absent, exit now:
  if [ ! -d /lib/modules/$RD_KVER ]; then
    echo "${COLOR_RED};Error: No /lib/modules/$RD_KVER kernel modules tree found !${COLOR_OFF}"
    exit 1
  fi
elif [ "$BUILD_MODE" = "runself" ]; then
  if [ -z "$PKGNAME" ]; then
    echo "${COLOR_RED}mistral: must specify a command, e.g. brzpkg${COLOR_OFF}"
    exit 1
  fi

  if [ -z "$(which $PKGNAME)" ]; then
    echo "${COLOR_RED}mistral: no such command, e.g. brzpkg${COLOR_OFF}"
    exit 1
  fi

  LICENSE="/etc/lsm/catalog/${PKGNAME}.license"

  if [ ! -e "$LICENSE" ]; then
    echo "${COLOR_RED}mistral: no such license -- $LICENSE !${COLOR_OFF}"
    exit 1
  fi

  LSMFILE="/etc/lsm/catalog/${PKGNAME}.lsm"

  if [ ! -e "$LSMFILE" ]; then
    echo "${COLOR_RED}mistral: no such package file -- $LSMFILE !${COLOR_OFF}"
    exit 1
  fi

  LSMTITLE="$(grep -Fi title $LSMFILE | cut -f2 -d: | crunch)"

  if [ ! -e /usr/share/mistral/runself/dorun.sh ]; then
    echo "${COLOR_RED}mistral: No such script file -- dorun.sh${COLOR_OFF}"
    exit 1
  fi

  if [ "$RS_JAIL" = "1" -o "$RS_JAIL" = "yes" ]; then
    if [ -z "$BIN_JAIL" ]; then
      echo "${COLOR_RED}mistral: No jail binary found -- firejail ${COLOR_OFF}"
      exit 1
    fi
  fi

  RD_OUTPUT=${RD_OUTPUT:-"$(pwd)/${PKGNAME}-${RD_ARCH}.run"}

  if [ -n "$RD_OUTPUT" -a "$RD_OUTPUT" = "$(basename $RD_OUTPUT)" ]; then
    RD_OUTPUT="$(pwd)/$RD_OUTPUT"
  fi
fi

# If clearing source tree was requested, do that first
if [ "$RD_CLEAR" = "1" -o "$RD_CLEAR" = "yes" -o "$BUILD_MODE" = "runself" ]; then
  if [ -z "$RD_WRAP" ] || [ "$RD_WRAP" = "0" -o "$RD_WRAP" = "no" ]; then
    if ! clear_source_tree ; then
     exit 1
    fi
  fi
fi

# If there's no ramdisk or runself layout, make one now:
if [ ! -d "$RD_LAYOUT" ]; then
  echo "mistral: using tree layout $RD_LAYOUT"
  if prompt_yesno "About to create the layout tree" ; then
    create_source_tree
  else
   exit 1
  fi
fi

if [ "$BUILD_MODE" = "runself" ]; then

  if [ "$RS_JAIL" = "1" -o "$RS_JAIL" = "yes" ]; then
    if [ -e "/etc/firejail/${PKGNAME}.profile" ]; then
      mkdir -p $RD_OUTPUT/etc/firejail
      cp /etc/firejail/${PKGNAME}.profile $RD_OUTPUT/etc/firejail/
      RD_BINARIES="$RD_BINARIES firejail"
    else
      echo "${COLOR_RED}Error: No firejail profile found for $PKGNAME !${COLOR_OFF}"
    fi
  fi

  # Copy needed binaries
  copy_binaries

  # Copy additional files
  copy_additional_files

  # Copy needed libraries
  copy_libraries "prune"

  # Copy overlay file layout
  if [ -n "$RD_OVERLAY" ]; then
    copy_overlay
  fi

  # Build runself archive
  build_runself_archive "$PKGNAME" "$(which $PKGNAME)"
  exit 0
fi

if [ "$RD_WRAP" = "1" -o "$RD_WRAP" = "yes" ]; then
  # Wrap the existing initrd:
  build_initrd_image
  exit $?
fi

if [ -z "$RD_NOROOT" ] || [ "$RD_NOROOT" = "0" -o "$RD_NOROOT" = "no" ]; then
  # If $RD_ROOTDEV and $RD_ROOTFS are not set, assume we want the
  # values for the currently mounted /
  # (unless we find that values are already set in the initrd-tree):

  if [ -z "$RD_ROOTDEV" -a -z "$(cat $RD_LAYOUT/rootdev 2>/dev/null)" ]; then
    RD_ROOTDEV=$(mount | grep ' on / ' | cut -f 1 -d ' ')

    if [ "$RD_ROOTDEV" = "/dev/root" ]; then # find real root device
      RD_ROOTDEV="/dev/$(readlink /dev/root)"
    fi

    if ! prompt_yesno "Warning: Assuming root device is '$RD_ROOTDEV'" ; then
      exit 1
    fi
  fi

  if echo "$RD_ROOTDEV" | grep -qF "/dev/mapper/" ; then
    RD_CRYPT="yes"
    RD_LVM="yes"
    RD_RAID="yes"
    RD_LUKSUUID=$($BIN_LSBLK -sn -lo UUID $RD_ROOTDEV | tr '\n' ' ' | cut -f2 -d' ')
    RD_ROOTUUID=$($BIN_BLKID -s UUID $RD_ROOTDEV | cut -f2 -d' ')
  else
    RD_ROOTUUID=$($BIN_BLKID -s UUID $RD_ROOTDEV | cut -f2 -d' ')
  fi

  if [ -z "$RD_ROOTFS" -a -z "$(cat $RD_LAYOUT/rootfs 2>/dev/null)" ]; then
    RD_ROOTFS=$(mount | grep ' on / ' | cut -f 5 -d ' ')

    if ! prompt_yesno "Warning: Assuming root filesystem type is $RD_ROOTFS" ; then
      exit 1
    fi
  fi

  if [ -n "$RD_ROOTDEV" ]; then
    echo $RD_ROOTDEV > $RD_LAYOUT/etc/rd.conf/rootdev
  else
    echo "${COLOR_RED}Error: No root device specified !${COLOR_OFF}"
    exit 1
  fi

  # If needed, write it to the initrd-tree:
  if [ -n "$RD_ROOTFS" ]; then
    echo $RD_ROOTFS > $RD_LAYOUT/etc/rd.conf/rootfs
  else
    echo "${COLOR_RED}Error: No root filesystem specified !${COLOR_OFF}"
    exit 1
  fi

  if [ -z "$RD_FILESYSTEMS" ] ; then
    RD_FILESYSTEMS="$ROOTFS"
  else
    RD_FILESYSTEMS="$RD_FILESYSTEMS $ROOTFS"
  fi

  if ! prompt_yesno "Warning: root device '$RD_ROOTUUID'" ; then
   exit 1
  fi

  if [ -n "$RD_ROOTUUID" ]; then
    echo $RD_ROOTUUID > $RD_LAYOUT/etc/rd.conf/rootuuid
    RD_CMDLINE="root=$RD_ROOTUUID"
  else
    echo "${COLOR_RED}Error: No root device uuid specified !${COLOR_OFF}"
    exit 1
  fi

  if [ "$RD_CRYPT" = "1" -o "$RD_CRYPT" = "yes" ]; then
    if ! prompt_yesno "Warning: root luks uuid '$RD_LUKSUUID'" ; then
     exit 1
    fi
  fi

  if [ -n "$RD_LUKSUUID" ]; then
    echo "$RD_LUKSUUID:luksroot" > $RD_LAYOUT/etc/rd.conf/luksuuid
    RD_CMDLINE="$RD_CMDLINE rd.luks.root=UUID=$RD_LUKSUUID"
  elif [ "$RD_CRYPT" = "1" -o "$RD_CRYPT" = "yes" ]; then
    echo "${COLOR_RED}Error: No LUKS UUID for root device found !${COLOR_OFF}"
    exit 1
  fi
fi

# If no RD_OUTPUT was specified:
RD_OUTPUT=${RD_OUTPUT:-"/boot/initramfs-${RD_PFX}-${RD_KVER}-${RD_ARCH}.img"}

# Finally, write the image name into the RD_LAYOUT:
echo "$MKINITRD_NAME" > $RD_LAYOUT/etc/rd.conf/initrd-name

# Fill resumedev with the swap partition holding the hibernation image
if [ -n "$RD_RESUME" ]; then
  echo $RD_RESUME > $RD_LAYOUT/etc/rd.conf/resumedev
fi

# Add custom keymap support if one was given
if [ -n "$RD_KEYMAP" ]; then
  echo $RD_KEYMAP > $RD_LAYOUT/etc/rd.conf/keymap
  cp /usr/share/mistral/keymaps.tar.gz $RD_LAYOUT/etc/
fi

if echo "$RD_FILESYSTEMS" | grep -qE '[v]?fat' ; then
  if ! echo "$RD_MODULES" | grep -qE '[v]?fat' ; then
    # This possibly adds doublures, but we clean up the MODULE_LIST further down!
    RD_MODULES="scsi_mod:sd_mod:sr_mod:dm-mod:dm-crypt:usbhid:usb_storage"
    RD_MODULES="$RD_MODULES:ehci-hcd:uhci-hcd:xhci-hcd:ehci-pci:usbhid:hid_generic"
    RD_MODULES="$RD_MODULES:usb-storage:hid:nls_cp437:nls_iso8859-1:msdos:fat:vfat"
  fi
fi

FS_MODULES="`echo "$RD_FILESYSTEMS" | tr -s ' ' ':'`"

# Add filesystems to list of modules to load
RD_MODULES="${RD_MODULES}:$FS_MODULES"

# Include OpenRC init support in initrd
if [ "$RD_OPENRC" = "1" -o "$RD_OPENRC" = "yes" ]; then
  enable_openrc
fi

# Include UDEV support in initrd
if [ "$RD_UDEV" = "1" -o "$RD_UDEV" = "yes" ]; then
  enable_udev
fi

# Include RAID support in initrd
if [ "$RD_RAID" = "1" -o "$RD_RAID" = "yes" ]; then
  enable_raid
fi

# Include LVM support in initrd
if [ "$RD_LVM" = "1" -o "$RD_LVM" = "yes" ]; then
  enable_lvm
fi

# Include EFI partition support in initrd
if [ "$RD_EFI" = "1" -o "$RD_EFI" = "yes" ]; then
  enable_efifs
fi

# Include cryptsetup LUKS support in initrd
if [ "$RD_CRYPT" = "1" -o "$RD_CRYPT" = "yes" ]; then
  enable_luks
fi

if [ "$RD_SPLASH" = "plymouth" ]; then
  enable_plymouth $RD_SPLASH_THEME
fi

if [ "$RD_SPLASH" = "mistral" ]; then
  enable_mistral $RD_SPLASH_THEME
fi

if [ "$RD_SPLASH" = "fbsplash" ]; then
  enable_fbsplash $RD_SPLASH_THEME
fi

# Copy overlay file layout
if [ -n "$RD_OVERLAY" ]; then
  copy_overlay
fi

# Make module directory:
if [ ! -d $RD_LAYOUT/lib/modules/$RD_KVER ]; then
  mkdir -p $RD_LAYOUT/lib/modules/$RD_KVER || exit 1
fi

# Copy kmod/modprobe stuff to initrd:
for i in kmod depmod insmod lsmod modinfo modprobe rmmod ; do

  bin=$(which ${i})

  if [ -z "$bin" ]; then
    echo "${COLOR_MAGENTA}Error: no such binary -- ${i}${COLOR_OFF}"
    continue
  fi

  if [ -e "$bin" ]; then
    rm -f $RD_LAYOUT/sbin/${bin}
    cp -a $bin $RD_LAYOUT/sbin
  else
    echo "${COLOR_MAGENTA}Error: no such binary -- $bin${COLOR_OFF}"
  fi

  RD_BINARIES="$RD_BINARIES ${bin}"
done

RD_BINARIES="$RD_BINARIES blkid lsblk findfs tr cut"

# Make sure modules.builtin and modules.order are there (for kmod):
cp -a /lib/modules/$RD_KVER/modules.builtin $RD_LAYOUT/lib/modules/$RD_KVER
cp -a /lib/modules/$RD_KVER/modules.order $RD_LAYOUT/lib/modules/$RD_KVER

# If an executable $RD_LAYOUT/bin/rd.modprobe.sh already exists, then
# we assume you will want to load the kernel modules mentioned in there.
# This means, you do not have to explicitly add those on the commandline:
if [ -x $RD_LAYOUT/bin/rd.modprobe.sh ]; then
  RD_MODULES="${RD_MODULES}:$(cat $RD_LAYOUT/bin/rd.modprobe.sh | grep '^modprobe' |rev |cut -d/ -f1 |rev |cut -d. -f1)"
fi

# Copy /{etc,lib}/modprobe.d/* if desired
if [ "$RD_MODCONF" = "1" -o "$RD_MODCONF" = "yes" ]; then
  copy_modconf
fi

# Copy the modules into place:
if [ -n "$RD_MODULES" ]; then
  copy_modules
fi

# Copy additional files
copy_additional_files

# Copy needed binaries
copy_binaries

# Copy needed libraries
copy_libraries

# Make sure all libraries have symlinks:
/sbin/ldconfig $(readlink -f $RD_LAYOUT)/lib/ 2> /dev/null
/sbin/ldconfig $(readlink -f $RD_LAYOUT)/lib64/ 2> /dev/null
/sbin/ldconfig

# And finally, build the initrd:
build_initrd_image

exit 0
